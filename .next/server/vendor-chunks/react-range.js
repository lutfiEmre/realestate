"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-range";
exports.ids = ["vendor-chunks/react-range"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-range/lib/Range.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/Range.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __extends = (void 0) && (void 0).__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (void 0) && (void 0).__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __importStar(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-range/lib/utils.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nvar INCREASE_KEYS = [\n    \"ArrowRight\",\n    \"ArrowUp\",\n    \"k\",\n    \"PageUp\"\n];\nvar DECREASE_KEYS = [\n    \"ArrowLeft\",\n    \"ArrowDown\",\n    \"j\",\n    \"PageDown\"\n];\nvar Range = /** @class */ function(_super) {\n    __extends(Range, _super);\n    function Range(props) {\n        var _this = _super.call(this, props) || this;\n        _this.trackRef = React.createRef();\n        _this.thumbRefs = [];\n        _this.state = {\n            draggedTrackPos: [\n                -1,\n                -1\n            ],\n            draggedThumbIndex: -1,\n            thumbZIndexes: new Array(_this.props.values.length).fill(0).map(function(t, i) {\n                return i;\n            }),\n            isChanged: false,\n            markOffsets: []\n        };\n        _this.getOffsets = function() {\n            var _a = _this.props, direction = _a.direction, values = _a.values, min = _a.min, max = _a.max;\n            var trackElement = _this.trackRef.current;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackPadding = (0, utils_1.getPaddingAndBorder)(trackElement);\n            return _this.getThumbs().map(function(thumb, index) {\n                var thumbOffsets = {\n                    x: 0,\n                    y: 0\n                };\n                var thumbRect = thumb.getBoundingClientRect();\n                var thumbMargins = (0, utils_1.getMargin)(thumb);\n                switch(direction){\n                    case types_1.Direction.Right:\n                        thumbOffsets.x = (thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y = ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x += trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) - thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Left:\n                        thumbOffsets.x = (thumbMargins.right + trackPadding.right) * -1;\n                        thumbOffsets.y = ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x += trackRect.width - trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) - thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Up:\n                        thumbOffsets.x = ((thumbRect.width - trackRect.width) / 2 + thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y += trackRect.height - trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) - thumbRect.height / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Down:\n                        thumbOffsets.x = ((thumbRect.width - trackRect.width) / 2 + thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y += trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) - thumbRect.height / 2;\n                        return thumbOffsets;\n                    default:\n                        return (0, utils_1.assertUnreachable)(direction);\n                }\n            });\n        };\n        _this.getThumbs = function() {\n            if (_this.trackRef && _this.trackRef.current) {\n                return Array.from(_this.trackRef.current.children).filter(function(el) {\n                    return el.hasAttribute(\"aria-valuenow\");\n                });\n            }\n            console.warn(\"No thumbs found in the track container. Did you forget to pass & spread the `props` param in renderTrack?\");\n            return [];\n        };\n        _this.getTargetIndex = function(e) {\n            return _this.getThumbs().findIndex(function(child) {\n                return child === e.target || child.contains(e.target);\n            });\n        };\n        _this.addTouchEvents = function(e) {\n            document.addEventListener(\"touchmove\", _this.schdOnTouchMove, {\n                passive: false\n            });\n            document.addEventListener(\"touchend\", _this.schdOnEnd, {\n                passive: false\n            });\n            document.addEventListener(\"touchcancel\", _this.schdOnEnd, {\n                passive: false\n            });\n        };\n        _this.addMouseEvents = function(e) {\n            document.addEventListener(\"mousemove\", _this.schdOnMouseMove);\n            document.addEventListener(\"mouseup\", _this.schdOnEnd);\n        };\n        _this.onMouseDownTrack = function(e) {\n            var _a;\n            if (e.button !== 0) return;\n            e.persist();\n            e.preventDefault();\n            _this.addMouseEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function(thumbRef) {\n                    var _a;\n                    return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target);\n                })) return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [\n                        e.clientX,\n                        e.clientY\n                    ]\n                }, function() {\n                    return _this.onMove(e.clientX, e.clientY);\n                });\n            } else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function(t) {\n                    return t.current;\n                }), e.clientX, e.clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex\n                }, function() {\n                    return _this.onMove(e.clientX, e.clientY);\n                });\n            }\n        };\n        _this.onResize = function() {\n            (0, utils_1.translateThumbs)(_this.getThumbs(), _this.getOffsets(), _this.props.rtl);\n            _this.calculateMarkOffsets();\n        };\n        _this.onTouchStartTrack = function(e) {\n            var _a;\n            e.persist();\n            _this.addTouchEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function(thumbRef) {\n                    var _a;\n                    return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target);\n                })) return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [\n                        e.touches[0].clientX,\n                        e.touches[0].clientY\n                    ]\n                }, function() {\n                    return _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n                });\n            } else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function(t) {\n                    return t.current;\n                }), e.touches[0].clientX, e.touches[0].clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex\n                }, function() {\n                    return _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n                });\n            }\n        };\n        _this.onMouseOrTouchStart = function(e) {\n            if (_this.props.disabled) return;\n            var isTouch = (0, utils_1.isTouchEvent)(e);\n            if (!isTouch && e.button !== 0) return;\n            var index = _this.getTargetIndex(e);\n            if (index === -1) return;\n            if (isTouch) {\n                _this.addTouchEvents(e);\n            } else {\n                _this.addMouseEvents(e);\n            }\n            _this.setState({\n                draggedThumbIndex: index,\n                thumbZIndexes: _this.state.thumbZIndexes.map(function(t, i) {\n                    if (i === index) {\n                        return Math.max.apply(Math, _this.state.thumbZIndexes);\n                    }\n                    return t <= _this.state.thumbZIndexes[index] ? t : t - 1;\n                })\n            });\n        };\n        _this.onMouseMove = function(e) {\n            e.preventDefault();\n            _this.onMove(e.clientX, e.clientY);\n        };\n        _this.onTouchMove = function(e) {\n            e.preventDefault();\n            _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n        };\n        _this.onKeyDown = function(e) {\n            var _a = _this.props, values = _a.values, onChange = _a.onChange, step = _a.step, rtl = _a.rtl, direction = _a.direction;\n            var isChanged = _this.state.isChanged;\n            var index = _this.getTargetIndex(e.nativeEvent);\n            var inverter = rtl || direction === types_1.Direction.Left || direction === types_1.Direction.Down ? -1 : 1;\n            if (index === -1) return;\n            if (INCREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] + inverter * (e.key === \"PageUp\" ? step * 10 : step), index)));\n            } else if (DECREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] - inverter * (e.key === \"PageDown\" ? step * 10 : step), index)));\n            } else if (e.key === \"Tab\") {\n                _this.setState({\n                    draggedThumbIndex: -1\n                }, function() {\n                    // If key pressed when thumb was moving, fire onFinalChange\n                    if (isChanged) {\n                        _this.fireOnFinalChange();\n                    }\n                });\n            } else {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            }\n        };\n        _this.onKeyUp = function(e) {\n            var isChanged = _this.state.isChanged;\n            _this.setState({\n                draggedThumbIndex: -1\n            }, function() {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            });\n        };\n        _this.onMove = function(clientX, clientY) {\n            var _a = _this.state, draggedThumbIndex = _a.draggedThumbIndex, draggedTrackPos = _a.draggedTrackPos;\n            var _b = _this.props, direction = _b.direction, min = _b.min, max = _b.max, onChange = _b.onChange, values = _b.values, step = _b.step, rtl = _b.rtl;\n            if (draggedThumbIndex === -1 && draggedTrackPos[0] === -1 && draggedTrackPos[1] === -1) return null;\n            var trackElement = _this.trackRef.current;\n            // If component was closed down prematurely, A last onMove could be triggered based on requestAnimationFrame()\n            if (!trackElement) return null;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackLength = (0, utils_1.isVertical)(direction) ? trackRect.height : trackRect.width;\n            if (draggedTrackPos[0] !== -1 && draggedTrackPos[1] !== -1) {\n                // calculate how much it moved since the last update\n                var dX = clientX - draggedTrackPos[0];\n                var dY = clientY - draggedTrackPos[1];\n                // calculate the delta of the value\n                var deltaValue = 0;\n                switch(direction){\n                    case types_1.Direction.Right:\n                    case types_1.Direction.Left:\n                        deltaValue = dX / trackLength * (max - min);\n                        break;\n                    case types_1.Direction.Down:\n                    case types_1.Direction.Up:\n                        deltaValue = dY / trackLength * (max - min);\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    deltaValue *= -1;\n                }\n                if (Math.abs(deltaValue) >= step / 2) {\n                    // adjust delta so it fits into the range\n                    for(var i = 0; i < _this.thumbRefs.length; i++){\n                        if (values[i] === max && Math.sign(deltaValue) === 1 || values[i] === min && Math.sign(deltaValue) === -1) return;\n                        var thumbValue = values[i] + deltaValue;\n                        if (thumbValue > max) deltaValue = max - values[i];\n                        else if (thumbValue < min) deltaValue = min - values[i];\n                    }\n                    // add the delta to each thumb\n                    var newValues = values.slice(0);\n                    for(var i = 0; i < _this.thumbRefs.length; i++){\n                        newValues = (0, utils_1.replaceAt)(newValues, i, _this.normalizeValue(values[i] + deltaValue, i));\n                    }\n                    _this.setState({\n                        draggedTrackPos: [\n                            clientX,\n                            clientY\n                        ]\n                    });\n                    onChange(newValues);\n                }\n            } else {\n                var newValue = 0;\n                switch(direction){\n                    case types_1.Direction.Right:\n                        newValue = (clientX - trackRect.left) / trackLength * (max - min) + min;\n                        break;\n                    case types_1.Direction.Left:\n                        newValue = (trackLength - (clientX - trackRect.left)) / trackLength * (max - min) + min;\n                        break;\n                    case types_1.Direction.Down:\n                        newValue = (clientY - trackRect.top) / trackLength * (max - min) + min;\n                        break;\n                    case types_1.Direction.Up:\n                        newValue = (trackLength - (clientY - trackRect.top)) / trackLength * (max - min) + min;\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    newValue = max + min - newValue;\n                }\n                if (Math.abs(values[draggedThumbIndex] - newValue) >= step / 2) {\n                    onChange((0, utils_1.replaceAt)(values, draggedThumbIndex, _this.normalizeValue(newValue, draggedThumbIndex)));\n                }\n            }\n        };\n        _this.normalizeValue = function(value, index) {\n            var _a = _this.props, min = _a.min, max = _a.max, step = _a.step, allowOverlap = _a.allowOverlap, values = _a.values;\n            return (0, utils_1.normalizeValue)(value, index, min, max, step, allowOverlap, values);\n        };\n        _this.onEnd = function(e) {\n            e.preventDefault();\n            document.removeEventListener(\"mousemove\", _this.schdOnMouseMove);\n            document.removeEventListener(\"touchmove\", _this.schdOnTouchMove);\n            document.removeEventListener(\"mouseup\", _this.schdOnEnd);\n            document.removeEventListener(\"touchend\", _this.schdOnEnd);\n            document.removeEventListener(\"touchcancel\", _this.schdOnEnd);\n            if (_this.state.draggedThumbIndex === -1 && _this.state.draggedTrackPos[0] === -1 && _this.state.draggedTrackPos[1] === -1) return null;\n            _this.setState({\n                draggedThumbIndex: -1,\n                draggedTrackPos: [\n                    -1,\n                    -1\n                ]\n            }, function() {\n                _this.fireOnFinalChange();\n            });\n        };\n        _this.fireOnFinalChange = function() {\n            _this.setState({\n                isChanged: false\n            });\n            var _a = _this.props, onFinalChange = _a.onFinalChange, values = _a.values;\n            if (onFinalChange) {\n                onFinalChange(values);\n            }\n        };\n        _this.updateMarkRefs = function(props) {\n            if (!props.renderMark) {\n                _this.numOfMarks = undefined;\n                _this.markRefs = undefined;\n                return;\n            }\n            _this.numOfMarks = (props.max - props.min) / _this.props.step;\n            _this.markRefs = [];\n            for(var i = 0; i < _this.numOfMarks + 1; i++){\n                _this.markRefs[i] = React.createRef();\n            }\n        };\n        _this.calculateMarkOffsets = function() {\n            if (!_this.props.renderMark || !_this.trackRef || !_this.numOfMarks || !_this.markRefs || _this.trackRef.current === null) return;\n            var elStyles = window.getComputedStyle(_this.trackRef.current);\n            var trackWidth = parseInt(elStyles.width, 10);\n            var trackHeight = parseInt(elStyles.height, 10);\n            var paddingLeft = parseInt(elStyles.paddingLeft, 10);\n            var paddingTop = parseInt(elStyles.paddingTop, 10);\n            var res = [];\n            for(var i = 0; i < _this.numOfMarks + 1; i++){\n                var markHeight = 9999;\n                var markWidth = 9999;\n                if (_this.markRefs[i].current) {\n                    var markRect = _this.markRefs[i].current.getBoundingClientRect();\n                    markHeight = markRect.height;\n                    markWidth = markRect.width;\n                }\n                if (_this.props.direction === types_1.Direction.Left || _this.props.direction === types_1.Direction.Right) {\n                    res.push([\n                        Math.round(trackWidth / _this.numOfMarks * i + paddingLeft - markWidth / 2),\n                        -Math.round((markHeight - trackHeight) / 2)\n                    ]);\n                } else {\n                    res.push([\n                        Math.round(trackHeight / _this.numOfMarks * i + paddingTop - markHeight / 2),\n                        -Math.round((markWidth - trackWidth) / 2)\n                    ]);\n                }\n            }\n            _this.setState({\n                markOffsets: res\n            });\n        };\n        if (props.step === 0) {\n            throw new Error('\"step\" property should be a positive number');\n        }\n        _this.schdOnMouseMove = (0, utils_1.schd)(_this.onMouseMove);\n        _this.schdOnTouchMove = (0, utils_1.schd)(_this.onTouchMove);\n        _this.schdOnEnd = (0, utils_1.schd)(_this.onEnd);\n        _this.thumbRefs = props.values.map(function() {\n            return React.createRef();\n        });\n        _this.updateMarkRefs(props);\n        return _this;\n    }\n    Range.prototype.componentDidMount = function() {\n        var _this = this;\n        var _a = this.props, values = _a.values, min = _a.min, step = _a.step;\n        this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver(this.onResize) : {\n            observe: function() {\n                return window.addEventListener(\"resize\", _this.onResize);\n            },\n            unobserve: function() {\n                return window.removeEventListener(\"resize\", _this.onResize);\n            }\n        };\n        document.addEventListener(\"touchstart\", this.onMouseOrTouchStart, {\n            passive: false\n        });\n        document.addEventListener(\"mousedown\", this.onMouseOrTouchStart, {\n            passive: false\n        });\n        !this.props.allowOverlap && (0, utils_1.checkInitialOverlap)(this.props.values);\n        this.props.values.forEach(function(value) {\n            return (0, utils_1.checkBoundaries)(value, _this.props.min, _this.props.max);\n        });\n        this.resizeObserver.observe(this.trackRef.current);\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), this.props.rtl);\n        this.calculateMarkOffsets();\n        values.forEach(function(value) {\n            if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                console.warn(\"The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.\");\n            }\n        });\n    };\n    Range.prototype.componentDidUpdate = function(prevProps, prevState) {\n        var _a = this.props, max = _a.max, min = _a.min, step = _a.step, values = _a.values, rtl = _a.rtl;\n        if (prevProps.max !== max || prevProps.min !== min || prevProps.step !== step) {\n            this.updateMarkRefs(this.props);\n        }\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), rtl);\n        // ensure offsets are calculated when the refs for the marks have been created\n        // and those refs have been mounted to the dom\n        // on the state update in calculateOffsets with new markOffsets are calculated\n        if (prevProps.max !== max || prevProps.min !== min || prevProps.step !== step || prevState.markOffsets.length !== this.state.markOffsets.length) {\n            this.calculateMarkOffsets();\n            values.forEach(function(value) {\n                if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                    console.warn(\"The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.\");\n                }\n            });\n        }\n    };\n    Range.prototype.componentWillUnmount = function() {\n        var options = {\n            passive: false\n        };\n        document.removeEventListener(\"mousedown\", this.onMouseOrTouchStart, options);\n        // These need to be removed!!\n        document.removeEventListener(\"mousemove\", this.schdOnMouseMove);\n        document.removeEventListener(\"touchmove\", this.schdOnTouchMove);\n        document.removeEventListener(\"touchstart\", this.onMouseOrTouchStart);\n        document.removeEventListener(\"mouseup\", this.schdOnEnd);\n        document.removeEventListener(\"touchend\", this.schdOnEnd);\n        this.resizeObserver.unobserve(this.trackRef.current);\n    };\n    Range.prototype.render = function() {\n        var _this = this;\n        var _a = this.props, renderTrack = _a.renderTrack, renderThumb = _a.renderThumb, _b = _a.renderMark, renderMark = _b === void 0 ? function() {\n            return null;\n        } : _b, values = _a.values, min = _a.min, max = _a.max, allowOverlap = _a.allowOverlap, disabled = _a.disabled;\n        var _c = this.state, draggedThumbIndex = _c.draggedThumbIndex, thumbZIndexes = _c.thumbZIndexes, markOffsets = _c.markOffsets;\n        return renderTrack({\n            props: {\n                style: {\n                    // creates stacking context that prevents z-index applied to thumbs\n                    // interfere with other elements\n                    transform: \"scale(1)\",\n                    cursor: draggedThumbIndex > -1 ? \"grabbing\" : this.props.draggableTrack ? (0, utils_1.isVertical)(this.props.direction) ? \"ns-resize\" : \"ew-resize\" : values.length === 1 && !disabled ? \"pointer\" : \"inherit\"\n                },\n                onMouseDown: disabled ? utils_1.voidFn : this.onMouseDownTrack,\n                onTouchStart: disabled ? utils_1.voidFn : this.onTouchStartTrack,\n                ref: this.trackRef\n            },\n            isDragged: this.state.draggedThumbIndex > -1,\n            disabled: disabled,\n            children: __spreadArray(__spreadArray([], markOffsets.map(function(offset, index, arr) {\n                return renderMark({\n                    props: {\n                        style: _this.props.direction === types_1.Direction.Left || _this.props.direction === types_1.Direction.Right ? {\n                            position: \"absolute\",\n                            left: \"\".concat(offset[0], \"px\"),\n                            marginTop: \"\".concat(offset[1], \"px\")\n                        } : {\n                            position: \"absolute\",\n                            top: \"\".concat(offset[0], \"px\"),\n                            marginLeft: \"\".concat(offset[1], \"px\")\n                        },\n                        key: \"mark\".concat(index),\n                        ref: _this.markRefs[index]\n                    },\n                    index: index\n                });\n            }), true), values.map(function(value, index) {\n                var isDragged = _this.state.draggedThumbIndex === index;\n                return renderThumb({\n                    index: index,\n                    value: value,\n                    isDragged: isDragged,\n                    props: {\n                        style: {\n                            position: \"absolute\",\n                            zIndex: thumbZIndexes[index],\n                            cursor: disabled ? \"inherit\" : isDragged ? \"grabbing\" : \"grab\",\n                            userSelect: \"none\",\n                            touchAction: \"none\",\n                            WebkitUserSelect: \"none\",\n                            MozUserSelect: \"none\",\n                            msUserSelect: \"none\"\n                        },\n                        key: index,\n                        tabIndex: disabled ? undefined : 0,\n                        \"aria-valuemax\": allowOverlap ? max : values[index + 1] || max,\n                        \"aria-valuemin\": allowOverlap ? min : values[index - 1] || min,\n                        \"aria-valuenow\": value,\n                        draggable: false,\n                        ref: _this.thumbRefs[index],\n                        role: \"slider\",\n                        onKeyDown: disabled ? utils_1.voidFn : _this.onKeyDown,\n                        onKeyUp: disabled ? utils_1.voidFn : _this.onKeyUp\n                    }\n                });\n            }), true)\n        });\n    };\n    Range.defaultProps = {\n        step: 1,\n        direction: types_1.Direction.Right,\n        rtl: false,\n        disabled: false,\n        allowOverlap: false,\n        draggableTrack: false,\n        min: 0,\n        max: 100\n    };\n    return Range;\n}(React.Component);\nexports[\"default\"] = Range;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL1JhbmdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsWUFBWSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFNBQVMsSUFBSztJQUN4QyxJQUFJQyxnQkFBZ0IsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO1FBQzlCRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7WUFBRUMsV0FBVyxFQUFFO1FBQUMsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7WUFBSUQsRUFBRUksU0FBUyxHQUFHSDtRQUFHLEtBQzFFLFNBQVVELENBQUMsRUFBRUMsQ0FBQztZQUFJLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO1FBQUU7UUFDcEcsT0FBT1AsY0FBY0MsR0FBR0M7SUFDNUI7SUFDQSxPQUFPLFNBQVVELENBQUMsRUFBRUMsQ0FBQztRQUNqQixJQUFJLE9BQU9BLE1BQU0sY0FBY0EsTUFBTSxNQUNqQyxNQUFNLElBQUlTLFVBQVUseUJBQXlCQyxPQUFPVixLQUFLO1FBQzdERixjQUFjQyxHQUFHQztRQUNqQixTQUFTVztZQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHYjtRQUFHO1FBQ3RDQSxFQUFFTyxTQUFTLEdBQUdOLE1BQU0sT0FBT0MsT0FBT1ksTUFBTSxDQUFDYixLQUFNVyxDQUFBQSxHQUFHTCxTQUFTLEdBQUdOLEVBQUVNLFNBQVMsRUFBRSxJQUFJSyxJQUFHO0lBQ3RGO0FBQ0o7QUFDQSxJQUFJRyxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1iLENBQUFBLE9BQU9ZLE1BQU0sR0FBSSxTQUFTRSxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9B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SVQ7d0JBQzNELGlCQUFpQmlHLGVBQWVsRyxNQUFNVCxNQUFNLENBQUNtQixRQUFRLEVBQUUsSUFBSVY7d0JBQzNELGlCQUFpQjFDO3dCQUNqQjBNLFdBQVc7d0JBQ1hkLEtBQUtuSyxNQUFNRyxTQUFTLENBQUN3QixNQUFNO3dCQUMzQnVKLE1BQU07d0JBQ05wRixXQUFXUCxXQUFXOUYsUUFBUXdLLE1BQU0sR0FBR2pLLE1BQU04RixTQUFTO3dCQUN0RFMsU0FBU2hCLFdBQVc5RixRQUFRd0ssTUFBTSxHQUFHakssTUFBTXVHLE9BQU87b0JBQ3REO2dCQUNKO1lBQ0osSUFBSTtRQUNSO0lBQ0o7SUFDQTFHLE1BQU1zTCxZQUFZLEdBQUc7UUFDakJuRixNQUFNO1FBQ05oRixXQUFXdEIsUUFBUXdDLFNBQVMsQ0FBQ0MsS0FBSztRQUNsQytDLEtBQUs7UUFDTEssVUFBVTtRQUNWNEIsY0FBYztRQUNkNUMsZ0JBQWdCO1FBQ2hCdEQsS0FBSztRQUNMQyxLQUFLO0lBQ1Q7SUFDQSxPQUFPckI7QUFDWCxFQUFFTixNQUFNNkwsU0FBUztBQUNqQjlMLGtCQUFlLEdBQUdPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW50aXRsZWQzNi8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvUmFuZ2UuanM/MjE2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG52YXIgSU5DUkVBU0VfS0VZUyA9IFsnQXJyb3dSaWdodCcsICdBcnJvd1VwJywgJ2snLCAnUGFnZVVwJ107XG52YXIgREVDUkVBU0VfS0VZUyA9IFsnQXJyb3dMZWZ0JywgJ0Fycm93RG93bicsICdqJywgJ1BhZ2VEb3duJ107XG52YXIgUmFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhbmdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhbmdlKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50cmFja1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy50aHVtYlJlZnMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFstMSwgLTFdLFxuICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IC0xLFxuICAgICAgICAgICAgdGh1bWJaSW5kZXhlczogbmV3IEFycmF5KF90aGlzLnByb3BzLnZhbHVlcy5sZW5ndGgpLmZpbGwoMCkubWFwKGZ1bmN0aW9uICh0LCBpKSB7IHJldHVybiBpOyB9KSxcbiAgICAgICAgICAgIGlzQ2hhbmdlZDogZmFsc2UsXG4gICAgICAgICAgICBtYXJrT2Zmc2V0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0T2Zmc2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb24sIHZhbHVlcyA9IF9hLnZhbHVlcywgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXg7XG4gICAgICAgICAgICB2YXIgdHJhY2tFbGVtZW50ID0gX3RoaXMudHJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHZhciB0cmFja1JlY3QgPSB0cmFja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tQYWRkaW5nID0gKDAsIHV0aWxzXzEuZ2V0UGFkZGluZ0FuZEJvcmRlcikodHJhY2tFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUaHVtYnMoKS5tYXAoZnVuY3Rpb24gKHRodW1iLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciB0aHVtYk9mZnNldHMgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJSZWN0ID0gdGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRodW1iTWFyZ2lucyA9ICgwLCB1dGlsc18xLmdldE1hcmdpbikodGh1bWIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCA9ICh0aHVtYk1hcmdpbnMubGVmdCArIHRyYWNrUGFkZGluZy5sZWZ0KSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGh1bWJSZWN0LmhlaWdodCAtIHRyYWNrUmVjdC5oZWlnaHQpIC8gMiArIHRyYWNrUGFkZGluZy50b3ApICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC53aWR0aCAqICgwLCB1dGlsc18xLnJlbGF0aXZlVmFsdWUpKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCA9ICh0aHVtYk1hcmdpbnMucmlnaHQgKyB0cmFja1BhZGRpbmcucmlnaHQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3QuaGVpZ2h0IC0gdHJhY2tSZWN0LmhlaWdodCkgLyAyICsgdHJhY2tQYWRkaW5nLnRvcCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoICogKDAsIHV0aWxzXzEucmVsYXRpdmVWYWx1ZSkodmFsdWVzW2luZGV4XSwgbWluLCBtYXgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVtYk9mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uVXA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3Qud2lkdGggLSB0cmFja1JlY3Qud2lkdGgpIC8gMiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iTWFyZ2lucy5sZWZ0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tQYWRkaW5nLmxlZnQpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9IC10cmFja1BhZGRpbmcubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LmhlaWdodCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC5oZWlnaHQgKiAoMCwgdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKSh2YWx1ZXNbaW5kZXhdLCBtaW4sIG1heCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVtYk9mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uRG93bjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRodW1iUmVjdC53aWR0aCAtIHRyYWNrUmVjdC53aWR0aCkgLyAyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJNYXJnaW5zLmxlZnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1BhZGRpbmcubGVmdCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ID0gLXRyYWNrUGFkZGluZy5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3QuaGVpZ2h0ICogKDAsIHV0aWxzXzEucmVsYXRpdmVWYWx1ZSkodmFsdWVzW2luZGV4XSwgbWluLCBtYXgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmFzc2VydFVucmVhY2hhYmxlKShkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRUaHVtYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMudHJhY2tSZWYgJiYgX3RoaXMudHJhY2tSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKF90aGlzLnRyYWNrUmVmLmN1cnJlbnQuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyB0aHVtYnMgZm91bmQgaW4gdGhlIHRyYWNrIGNvbnRhaW5lci4gRGlkIHlvdSBmb3JnZXQgdG8gcGFzcyAmIHNwcmVhZCB0aGUgYHByb3BzYCBwYXJhbSBpbiByZW5kZXJUcmFjaz8nKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0VGFyZ2V0SW5kZXggPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFRodW1icygpLmZpbmRJbmRleChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkID09PSBlLnRhcmdldCB8fCBjaGlsZC5jb250YWlucyhlLnRhcmdldCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5hZGRUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfdGhpcy5zY2hkT25Ub3VjaE1vdmUsIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLnNjaGRPbkVuZCwge1xuICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX3RoaXMuc2NoZE9uRW5kLCB7XG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5hZGRNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5zY2hkT25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uTW91c2VEb3duVHJhY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXMuYWRkTW91c2VFdmVudHMoZS5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMudmFsdWVzLmxlbmd0aCA+IDEgJiYgX3RoaXMucHJvcHMuZHJhZ2dhYmxlVHJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudGh1bWJSZWZzLnNvbWUoZnVuY3Rpb24gKHRodW1iUmVmKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRodW1iUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhlLnRhcmdldCk7IH0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRyYWdnaW5nIHRoZSB3aG9sZSB0cmFja1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zOiBbZS5jbGllbnRYLCBlLmNsaWVudFldXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSB0aHVtYiB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHBsYWNlIHdoZXJlIHRoZSB0cmFjayBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdnZWRUaHVtYkluZGV4ID0gKDAsIHV0aWxzXzEuZ2V0Q2xvc2VzdFRodW1iSW5kZXgpKF90aGlzLnRodW1iUmVmcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuY3VycmVudDsgfSksIGUuY2xpZW50WCwgZS5jbGllbnRZLCBfdGhpcy5wcm9wcy5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIHRodW1iIHdoaWNoIGlzIGNsb3Nlc3QgdG8gdGhlIHBsYWNlIHdoZXJlIHRoZSB0cmFjayBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgKF9hID0gX3RoaXMudGh1bWJSZWZzW2RyYWdnZWRUaHVtYkluZGV4XS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiBkcmFnZ2VkVGh1bWJJbmRleFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW92ZShlLmNsaWVudFgsIGUuY2xpZW50WSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLnRyYW5zbGF0ZVRodW1icykoX3RoaXMuZ2V0VGh1bWJzKCksIF90aGlzLmdldE9mZnNldHMoKSwgX3RoaXMucHJvcHMucnRsKTtcbiAgICAgICAgICAgIF90aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uVG91Y2hTdGFydFRyYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMoZS5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMudmFsdWVzLmxlbmd0aCA+IDEgJiYgX3RoaXMucHJvcHMuZHJhZ2dhYmxlVHJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudGh1bWJSZWZzLnNvbWUoZnVuY3Rpb24gKHRodW1iUmVmKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRodW1iUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhlLnRhcmdldCk7IH0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRyYWdnaW5nIHRoZSB3aG9sZSB0cmFja1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zOiBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW92ZShlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIHRodW1iIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ2dlZFRodW1iSW5kZXggPSAoMCwgdXRpbHNfMS5nZXRDbG9zZXN0VGh1bWJJbmRleCkoX3RoaXMudGh1bWJSZWZzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5jdXJyZW50OyB9KSwgZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZLCBfdGhpcy5wcm9wcy5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIHRodW1iIHdoaWNoIGlzIGNsb3Nlc3QgdG8gdGhlIHBsYWNlIHdoZXJlIHRoZSB0cmFjayBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgKF9hID0gX3RoaXMudGh1bWJSZWZzW2RyYWdnZWRUaHVtYkluZGV4XS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiBkcmFnZ2VkVGh1bWJJbmRleFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW92ZShlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3VzZU9yVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzVG91Y2ggPSAoMCwgdXRpbHNfMS5pc1RvdWNoRXZlbnQpKGUpO1xuICAgICAgICAgICAgaWYgKCFpc1RvdWNoICYmIGUuYnV0dG9uICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLmdldFRhcmdldEluZGV4KGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZFRvdWNoRXZlbnRzKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkTW91c2VFdmVudHMoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHRodW1iWkluZGV4ZXM6IF90aGlzLnN0YXRlLnRodW1iWkluZGV4ZXMubWFwKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIF90aGlzLnN0YXRlLnRodW1iWkluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IDw9IF90aGlzLnN0YXRlLnRodW1iWkluZGV4ZXNbaW5kZXhdID8gdCA6IHQgLSAxO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXMub25Nb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXMub25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgdmFsdWVzID0gX2EudmFsdWVzLCBvbkNoYW5nZSA9IF9hLm9uQ2hhbmdlLCBzdGVwID0gX2Euc3RlcCwgcnRsID0gX2EucnRsLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb247XG4gICAgICAgICAgICB2YXIgaXNDaGFuZ2VkID0gX3RoaXMuc3RhdGUuaXNDaGFuZ2VkO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuZ2V0VGFyZ2V0SW5kZXgoZS5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICB2YXIgaW52ZXJ0ZXIgPSBydGwgfHwgZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0IHx8IGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uRG93blxuICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChJTkNSRUFTRV9LRVlTLmluY2x1ZGVzKGUua2V5KSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNDaGFuZ2VkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UoKDAsIHV0aWxzXzEucmVwbGFjZUF0KSh2YWx1ZXMsIGluZGV4LCBfdGhpcy5ub3JtYWxpemVWYWx1ZSh2YWx1ZXNbaW5kZXhdICsgaW52ZXJ0ZXIgKiAoZS5rZXkgPT09ICdQYWdlVXAnID8gc3RlcCAqIDEwIDogc3RlcCksIGluZGV4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoREVDUkVBU0VfS0VZUy5pbmNsdWRlcyhlLmtleSkpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbmdlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCgwLCB1dGlsc18xLnJlcGxhY2VBdCkodmFsdWVzLCBpbmRleCwgX3RoaXMubm9ybWFsaXplVmFsdWUodmFsdWVzW2luZGV4XSAtXG4gICAgICAgICAgICAgICAgICAgIGludmVydGVyICogKGUua2V5ID09PSAnUGFnZURvd24nID8gc3RlcCAqIDEwIDogc3RlcCksIGluZGV4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdUYWInKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBkcmFnZ2VkVGh1bWJJbmRleDogLTEgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBrZXkgcHJlc3NlZCB3aGVuIHRodW1iIHdhcyBtb3ZpbmcsIGZpcmUgb25GaW5hbENoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbktleVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBpc0NoYW5nZWQgPSBfdGhpcy5zdGF0ZS5pc0NoYW5nZWQ7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IC0xXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdmUgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuc3RhdGUsIGRyYWdnZWRUaHVtYkluZGV4ID0gX2EuZHJhZ2dlZFRodW1iSW5kZXgsIGRyYWdnZWRUcmFja1BvcyA9IF9hLmRyYWdnZWRUcmFja1BvcztcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLCBkaXJlY3Rpb24gPSBfYi5kaXJlY3Rpb24sIG1pbiA9IF9iLm1pbiwgbWF4ID0gX2IubWF4LCBvbkNoYW5nZSA9IF9iLm9uQ2hhbmdlLCB2YWx1ZXMgPSBfYi52YWx1ZXMsIHN0ZXAgPSBfYi5zdGVwLCBydGwgPSBfYi5ydGw7XG4gICAgICAgICAgICBpZiAoZHJhZ2dlZFRodW1iSW5kZXggPT09IC0xICYmXG4gICAgICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zWzBdID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1Bvc1sxXSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdHJhY2tFbGVtZW50ID0gX3RoaXMudHJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgICAgIC8vIElmIGNvbXBvbmVudCB3YXMgY2xvc2VkIGRvd24gcHJlbWF0dXJlbHksIEEgbGFzdCBvbk1vdmUgY291bGQgYmUgdHJpZ2dlcmVkIGJhc2VkIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpXG4gICAgICAgICAgICBpZiAoIXRyYWNrRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciB0cmFja1JlY3QgPSB0cmFja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tMZW5ndGggPSAoMCwgdXRpbHNfMS5pc1ZlcnRpY2FsKShkaXJlY3Rpb24pXG4gICAgICAgICAgICAgICAgPyB0cmFja1JlY3QuaGVpZ2h0XG4gICAgICAgICAgICAgICAgOiB0cmFja1JlY3Qud2lkdGg7XG4gICAgICAgICAgICBpZiAoZHJhZ2dlZFRyYWNrUG9zWzBdICE9PSAtMSAmJiBkcmFnZ2VkVHJhY2tQb3NbMV0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGhvdyBtdWNoIGl0IG1vdmVkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAgICAgICAgICAgIHZhciBkWCA9IGNsaWVudFggLSBkcmFnZ2VkVHJhY2tQb3NbMF07XG4gICAgICAgICAgICAgICAgdmFyIGRZID0gY2xpZW50WSAtIGRyYWdnZWRUcmFja1Bvc1sxXTtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGRlbHRhIG9mIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gKGRYIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFWYWx1ZSA9IChkWSAvIHRyYWNrTGVuZ3RoKSAqIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnRVbnJlYWNoYWJsZSkoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW52ZXJ0IGZvciBSVExcbiAgICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YVZhbHVlKSA+PSBzdGVwIC8gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3QgZGVsdGEgc28gaXQgZml0cyBpbnRvIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnRodW1iUmVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZXNbaV0gPT09IG1heCAmJiBNYXRoLnNpZ24oZGVsdGFWYWx1ZSkgPT09IDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlc1tpXSA9PT0gbWluICYmIE1hdGguc2lnbihkZWx0YVZhbHVlKSA9PT0gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aHVtYlZhbHVlID0gdmFsdWVzW2ldICsgZGVsdGFWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHVtYlZhbHVlID4gbWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSBtYXggLSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aHVtYlZhbHVlIDwgbWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSBtaW4gLSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBkZWx0YSB0byBlYWNoIHRodW1iXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSB2YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMudGh1bWJSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMgPSAoMCwgdXRpbHNfMS5yZXBsYWNlQXQpKG5ld1ZhbHVlcywgaSwgX3RoaXMubm9ybWFsaXplVmFsdWUodmFsdWVzW2ldICsgZGVsdGFWYWx1ZSwgaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogW2NsaWVudFgsIGNsaWVudFldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGNsaWVudFggLSB0cmFja1JlY3QubGVmdCkgLyB0cmFja0xlbmd0aCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0cmFja0xlbmd0aCAtIChjbGllbnRYIC0gdHJhY2tSZWN0LmxlZnQpKSAvIHRyYWNrTGVuZ3RoKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXggLSBtaW4pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uRG93bjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGNsaWVudFkgLSB0cmFja1JlY3QudG9wKSAvIHRyYWNrTGVuZ3RoKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uVXA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0cmFja0xlbmd0aCAtIChjbGllbnRZIC0gdHJhY2tSZWN0LnRvcCkpIC8gdHJhY2tMZW5ndGgpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1heCAtIG1pbikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLmFzc2VydFVucmVhY2hhYmxlKShkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnZlcnQgZm9yIFJUTFxuICAgICAgICAgICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBtYXggKyBtaW4gLSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZhbHVlc1tkcmFnZ2VkVGh1bWJJbmRleF0gLSBuZXdWYWx1ZSkgPj0gc3RlcCAvIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoKDAsIHV0aWxzXzEucmVwbGFjZUF0KSh2YWx1ZXMsIGRyYWdnZWRUaHVtYkluZGV4LCBfdGhpcy5ub3JtYWxpemVWYWx1ZShuZXdWYWx1ZSwgZHJhZ2dlZFRodW1iSW5kZXgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5ub3JtYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heCwgc3RlcCA9IF9hLnN0ZXAsIGFsbG93T3ZlcmxhcCA9IF9hLmFsbG93T3ZlcmxhcCwgdmFsdWVzID0gX2EudmFsdWVzO1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLm5vcm1hbGl6ZVZhbHVlKSh2YWx1ZSwgaW5kZXgsIG1pbiwgbWF4LCBzdGVwLCBhbGxvd092ZXJsYXAsIHZhbHVlcyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF90aGlzLnNjaGRPbk1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfdGhpcy5zY2hkT25Ub3VjaE1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF90aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuZHJhZ2dlZFRodW1iSW5kZXggPT09IC0xICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUuZHJhZ2dlZFRyYWNrUG9zWzBdID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmRyYWdnZWRUcmFja1Bvc1sxXSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGRyYWdnZWRUaHVtYkluZGV4OiAtMSwgZHJhZ2dlZFRyYWNrUG9zOiBbLTEsIC0xXSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNDaGFuZ2VkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBvbkZpbmFsQ2hhbmdlID0gX2Eub25GaW5hbENoYW5nZSwgdmFsdWVzID0gX2EudmFsdWVzO1xuICAgICAgICAgICAgaWYgKG9uRmluYWxDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmFsQ2hhbmdlKHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnVwZGF0ZU1hcmtSZWZzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLnJlbmRlck1hcmspIHsgLy8gZG9uJ3QgY3JlYXRlIG1hcmsgcmVmcyB1bmxlc3Mgd2UgYXJlIHJlbmRlcmluZyBtYXJrc1xuICAgICAgICAgICAgICAgIF90aGlzLm51bU9mTWFya3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFya1JlZnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMubnVtT2ZNYXJrcyA9IChwcm9wcy5tYXggLSBwcm9wcy5taW4pIC8gX3RoaXMucHJvcHMuc3RlcDtcbiAgICAgICAgICAgIF90aGlzLm1hcmtSZWZzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLm51bU9mTWFya3MgKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYXJrUmVmc1tpXSA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jYWxjdWxhdGVNYXJrT2Zmc2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMucmVuZGVyTWFyayB8fFxuICAgICAgICAgICAgICAgICFfdGhpcy50cmFja1JlZiB8fFxuICAgICAgICAgICAgICAgICFfdGhpcy5udW1PZk1hcmtzIHx8XG4gICAgICAgICAgICAgICAgIV90aGlzLm1hcmtSZWZzIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2tSZWYuY3VycmVudCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgZWxTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShfdGhpcy50cmFja1JlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHZhciB0cmFja1dpZHRoID0gcGFyc2VJbnQoZWxTdHlsZXMud2lkdGgsIDEwKTtcbiAgICAgICAgICAgIHZhciB0cmFja0hlaWdodCA9IHBhcnNlSW50KGVsU3R5bGVzLmhlaWdodCwgMTApO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoZWxTdHlsZXMucGFkZGluZ0xlZnQsIDEwKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nVG9wID0gcGFyc2VJbnQoZWxTdHlsZXMucGFkZGluZ1RvcCwgMTApO1xuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5udW1PZk1hcmtzICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtIZWlnaHQgPSA5OTk5O1xuICAgICAgICAgICAgICAgIHZhciBtYXJrV2lkdGggPSA5OTk5O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5tYXJrUmVmc1tpXS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJrUmVjdCA9IF90aGlzLm1hcmtSZWZzW2ldLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtIZWlnaHQgPSBtYXJrUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtXaWR0aCA9IG1hcmtSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0IHx8XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgodHJhY2tXaWR0aCAvIF90aGlzLm51bU9mTWFya3MpICogaSArIHBhZGRpbmdMZWZ0IC0gbWFya1dpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAtTWF0aC5yb3VuZCgobWFya0hlaWdodCAtIHRyYWNrSGVpZ2h0KSAvIDIpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgodHJhY2tIZWlnaHQgLyBfdGhpcy5udW1PZk1hcmtzKSAqIGkgKyBwYWRkaW5nVG9wIC0gbWFya0hlaWdodCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLU1hdGgucm91bmQoKG1hcmtXaWR0aCAtIHRyYWNrV2lkdGgpIC8gMilcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBtYXJrT2Zmc2V0czogcmVzIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvcHMuc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInN0ZXBcIiBwcm9wZXJ0eSBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zY2hkT25Nb3VzZU1vdmUgPSAoMCwgdXRpbHNfMS5zY2hkKShfdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIF90aGlzLnNjaGRPblRvdWNoTW92ZSA9ICgwLCB1dGlsc18xLnNjaGQpKF90aGlzLm9uVG91Y2hNb3ZlKTtcbiAgICAgICAgX3RoaXMuc2NoZE9uRW5kID0gKDAsIHV0aWxzXzEuc2NoZCkoX3RoaXMub25FbmQpO1xuICAgICAgICBfdGhpcy50aHVtYlJlZnMgPSBwcm9wcy52YWx1ZXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZVJlZigpOyB9KTtcbiAgICAgICAgX3RoaXMudXBkYXRlTWFya1JlZnMocHJvcHMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdmFsdWVzID0gX2EudmFsdWVzLCBtaW4gPSBfYS5taW4sIHN0ZXAgPSBfYS5zdGVwO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gd2luZG93LlJlc2l6ZU9ic2VydmVyXG4gICAgICAgICAgICA/IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIodGhpcy5vblJlc2l6ZSlcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIG9ic2VydmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfdGhpcy5vblJlc2l6ZSk7IH0sXG4gICAgICAgICAgICAgICAgdW5vYnNlcnZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgX3RoaXMub25SZXNpemUpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0LCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0LCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgIXRoaXMucHJvcHMuYWxsb3dPdmVybGFwICYmICgwLCB1dGlsc18xLmNoZWNrSW5pdGlhbE92ZXJsYXApKHRoaXMucHJvcHMudmFsdWVzKTtcbiAgICAgICAgdGhpcy5wcm9wcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jaGVja0JvdW5kYXJpZXMpKHZhbHVlLCBfdGhpcy5wcm9wcy5taW4sIF90aGlzLnByb3BzLm1heCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy50cmFja1JlZi5jdXJyZW50KTtcbiAgICAgICAgKDAsIHV0aWxzXzEudHJhbnNsYXRlVGh1bWJzKSh0aGlzLmdldFRodW1icygpLCB0aGlzLmdldE9mZnNldHMoKSwgdGhpcy5wcm9wcy5ydGwpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzKCk7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc1N0ZXBEaXZpc2libGUpKG1pbiwgdmFsdWUsIHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgYHZhbHVlc2AgcHJvcGVydHkgaXMgaW4gY29uZmxpY3Qgd2l0aCB0aGUgY3VycmVudCBgc3RlcGAsIGBtaW5gLCBhbmQgYG1heGAgcHJvcGVydGllcy4gUGxlYXNlIHByb3ZpZGUgdmFsdWVzIHRoYXQgYXJlIGFjY2Vzc2libGUgdXNpbmcgdGhlIG1pbiwgbWF4LCBhbmQgc3RlcCB2YWx1ZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBtYXggPSBfYS5tYXgsIG1pbiA9IF9hLm1pbiwgc3RlcCA9IF9hLnN0ZXAsIHZhbHVlcyA9IF9hLnZhbHVlcywgcnRsID0gX2EucnRsO1xuICAgICAgICBpZiAocHJldlByb3BzLm1heCAhPT0gbWF4IHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMubWluICE9PSBtaW4gfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5zdGVwICE9PSBzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hcmtSZWZzKHRoaXMucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgICgwLCB1dGlsc18xLnRyYW5zbGF0ZVRodW1icykodGhpcy5nZXRUaHVtYnMoKSwgdGhpcy5nZXRPZmZzZXRzKCksIHJ0bCk7XG4gICAgICAgIC8vIGVuc3VyZSBvZmZzZXRzIGFyZSBjYWxjdWxhdGVkIHdoZW4gdGhlIHJlZnMgZm9yIHRoZSBtYXJrcyBoYXZlIGJlZW4gY3JlYXRlZFxuICAgICAgICAvLyBhbmQgdGhvc2UgcmVmcyBoYXZlIGJlZW4gbW91bnRlZCB0byB0aGUgZG9tXG4gICAgICAgIC8vIG9uIHRoZSBzdGF0ZSB1cGRhdGUgaW4gY2FsY3VsYXRlT2Zmc2V0cyB3aXRoIG5ldyBtYXJrT2Zmc2V0cyBhcmUgY2FsY3VsYXRlZFxuICAgICAgICBpZiAocHJldlByb3BzLm1heCAhPT0gbWF4IHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMubWluICE9PSBtaW4gfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5zdGVwICE9PSBzdGVwIHx8XG4gICAgICAgICAgICBwcmV2U3RhdGUubWFya09mZnNldHMubGVuZ3RoICE9PSB0aGlzLnN0YXRlLm1hcmtPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVNYXJrT2Zmc2V0cygpO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc1N0ZXBEaXZpc2libGUpKG1pbiwgdmFsdWUsIHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGB2YWx1ZXNgIHByb3BlcnR5IGlzIGluIGNvbmZsaWN0IHdpdGggdGhlIGN1cnJlbnQgYHN0ZXBgLCBgbWluYCwgYW5kIGBtYXhgIHByb3BlcnRpZXMuIFBsZWFzZSBwcm92aWRlIHZhbHVlcyB0aGF0IGFyZSBhY2Nlc3NpYmxlIHVzaW5nIHRoZSBtaW4sIG1heCwgYW5kIHN0ZXAgdmFsdWVzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0LCBvcHRpb25zKTtcbiAgICAgICAgLy8gVGhlc2UgbmVlZCB0byBiZSByZW1vdmVkISFcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5zY2hkT25Nb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLnNjaGRPblRvdWNoTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uTW91c2VPclRvdWNoU3RhcnQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy50cmFja1JlZi5jdXJyZW50KTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHJlbmRlclRyYWNrID0gX2EucmVuZGVyVHJhY2ssIHJlbmRlclRodW1iID0gX2EucmVuZGVyVGh1bWIsIF9iID0gX2EucmVuZGVyTWFyaywgcmVuZGVyTWFyayA9IF9iID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9IDogX2IsIHZhbHVlcyA9IF9hLnZhbHVlcywgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXgsIGFsbG93T3ZlcmxhcCA9IF9hLmFsbG93T3ZlcmxhcCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZDtcbiAgICAgICAgdmFyIF9jID0gdGhpcy5zdGF0ZSwgZHJhZ2dlZFRodW1iSW5kZXggPSBfYy5kcmFnZ2VkVGh1bWJJbmRleCwgdGh1bWJaSW5kZXhlcyA9IF9jLnRodW1iWkluZGV4ZXMsIG1hcmtPZmZzZXRzID0gX2MubWFya09mZnNldHM7XG4gICAgICAgIHJldHVybiByZW5kZXJUcmFjayh7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZXMgc3RhY2tpbmcgY29udGV4dCB0aGF0IHByZXZlbnRzIHotaW5kZXggYXBwbGllZCB0byB0aHVtYnNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJmZXJlIHdpdGggb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IGRyYWdnZWRUaHVtYkluZGV4ID4gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ2dyYWJiaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByb3BzLmRyYWdnYWJsZVRyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgdXRpbHNfMS5pc1ZlcnRpY2FsKSh0aGlzLnByb3BzLmRpcmVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnbnMtcmVzaXplJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdldy1yZXNpemUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZXMubGVuZ3RoID09PSAxICYmICFkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdwb2ludGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdpbmhlcml0J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25Nb3VzZURvd246IGRpc2FibGVkID8gdXRpbHNfMS52b2lkRm4gOiB0aGlzLm9uTW91c2VEb3duVHJhY2ssXG4gICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogdGhpcy5vblRvdWNoU3RhcnRUcmFjayxcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMudHJhY2tSZWZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0RyYWdnZWQ6IHRoaXMuc3RhdGUuZHJhZ2dlZFRodW1iSW5kZXggPiAtMSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG1hcmtPZmZzZXRzLm1hcChmdW5jdGlvbiAob2Zmc2V0LCBpbmRleCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlck1hcmsoe1xuICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IF90aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IFwiXCIuY29uY2F0KG9mZnNldFswXSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBcIlwiLmNvbmNhdChvZmZzZXRbMV0sIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiXCIuY29uY2F0KG9mZnNldFswXSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogXCJcIi5jb25jYXQob2Zmc2V0WzFdLCBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJtYXJrXCIuY29uY2F0KGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogX3RoaXMubWFya1JlZnNbaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIHRydWUpLCB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNEcmFnZ2VkID0gX3RoaXMuc3RhdGUuZHJhZ2dlZFRodW1iSW5kZXggPT09IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJUaHVtYih7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpc0RyYWdnZWQ6IGlzRHJhZ2dlZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiB0aHVtYlpJbmRleGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IGRpc2FibGVkID8gJ2luaGVyaXQnIDogaXNEcmFnZ2VkID8gJ2dyYWJiaW5nJyA6ICdncmFiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWJraXRVc2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTW96VXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zVXNlclNlbGVjdDogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiBkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW1heCc6IGFsbG93T3ZlcmxhcCA/IG1heCA6IHZhbHVlc1tpbmRleCArIDFdIHx8IG1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbWluJzogYWxsb3dPdmVybGFwID8gbWluIDogdmFsdWVzW2luZGV4IC0gMV0gfHwgbWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVub3cnOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IF90aGlzLnRodW1iUmVmc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAnc2xpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bjogZGlzYWJsZWQgPyB1dGlsc18xLnZvaWRGbiA6IF90aGlzLm9uS2V5RG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5VXA6IGRpc2FibGVkID8gdXRpbHNfMS52b2lkRm4gOiBfdGhpcy5vbktleVVwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCB0cnVlKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJhbmdlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgc3RlcDogMSxcbiAgICAgICAgZGlyZWN0aW9uOiB0eXBlc18xLkRpcmVjdGlvbi5SaWdodCxcbiAgICAgICAgcnRsOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBhbGxvd092ZXJsYXA6IGZhbHNlLFxuICAgICAgICBkcmFnZ2FibGVUcmFjazogZmFsc2UsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxMDBcbiAgICB9O1xuICAgIHJldHVybiBSYW5nZTtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSYW5nZTtcbiJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIl9fIiwiY29uc3RydWN0b3IiLCJjcmVhdGUiLCJfX2NyZWF0ZUJpbmRpbmciLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJfX3NwcmVhZEFycmF5IiwidG8iLCJmcm9tIiwicGFjayIsImFyZ3VtZW50cyIsImxlbmd0aCIsImkiLCJsIiwiYXIiLCJzbGljZSIsImNvbmNhdCIsImV4cG9ydHMiLCJSZWFjdCIsInJlcXVpcmUiLCJ1dGlsc18xIiwidHlwZXNfMSIsIklOQ1JFQVNFX0tFWVMiLCJERUNSRUFTRV9LRVlTIiwiUmFuZ2UiLCJfc3VwZXIiLCJwcm9wcyIsIl90aGlzIiwidHJhY2tSZWYiLCJjcmVhdGVSZWYiLCJ0aHVtYlJlZnMiLCJzdGF0ZSIsImRyYWdnZWRUcmFja1BvcyIsImRyYWdnZWRUaHVtYkluZGV4IiwidGh1bWJaSW5kZXhlcyIsInZhbHVlcyIsImZpbGwiLCJtYXAiLCJ0IiwiaXNDaGFuZ2VkIiwibWFya09mZnNldHMiLCJnZXRPZmZzZXRzIiwiX2EiLCJkaXJlY3Rpb24iLCJtaW4iLCJtYXgiLCJ0cmFja0VsZW1lbnQiLCJjdXJyZW50IiwidHJhY2tSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidHJhY2tQYWRkaW5nIiwiZ2V0UGFkZGluZ0FuZEJvcmRlciIsImdldFRodW1icyIsInRodW1iIiwiaW5kZXgiLCJ0aHVtYk9mZnNldHMiLCJ4IiwieSIsInRodW1iUmVjdCIsInRodW1iTWFyZ2lucyIsImdldE1hcmdpbiIsIkRpcmVjdGlvbiIsIlJpZ2h0IiwibGVmdCIsImhlaWdodCIsInRvcCIsIndpZHRoIiwicmVsYXRpdmVWYWx1ZSIsIkxlZnQiLCJyaWdodCIsIlVwIiwiRG93biIsImFzc2VydFVucmVhY2hhYmxlIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJlbCIsImhhc0F0dHJpYnV0ZSIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0VGFyZ2V0SW5kZXgiLCJlIiwiZmluZEluZGV4IiwiY2hpbGQiLCJ0YXJnZXQiLCJjb250YWlucyIsImFkZFRvdWNoRXZlbnRzIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwic2NoZE9uVG91Y2hNb3ZlIiwicGFzc2l2ZSIsInNjaGRPbkVuZCIsImFkZE1vdXNlRXZlbnRzIiwic2NoZE9uTW91c2VNb3ZlIiwib25Nb3VzZURvd25UcmFjayIsImJ1dHRvbiIsInBlcnNpc3QiLCJwcmV2ZW50RGVmYXVsdCIsIm5hdGl2ZUV2ZW50IiwiZHJhZ2dhYmxlVHJhY2siLCJzb21lIiwidGh1bWJSZWYiLCJzZXRTdGF0ZSIsImNsaWVudFgiLCJjbGllbnRZIiwib25Nb3ZlIiwiZ2V0Q2xvc2VzdFRodW1iSW5kZXgiLCJmb2N1cyIsIm9uUmVzaXplIiwidHJhbnNsYXRlVGh1bWJzIiwicnRsIiwiY2FsY3VsYXRlTWFya09mZnNldHMiLCJvblRvdWNoU3RhcnRUcmFjayIsInRvdWNoZXMiLCJvbk1vdXNlT3JUb3VjaFN0YXJ0IiwiZGlzYWJsZWQiLCJpc1RvdWNoIiwiaXNUb3VjaEV2ZW50IiwiTWF0aCIsImFwcGx5Iiwib25Nb3VzZU1vdmUiLCJvblRvdWNoTW92ZSIsIm9uS2V5RG93biIsIm9uQ2hhbmdlIiwic3RlcCIsImludmVydGVyIiwiaW5jbHVkZXMiLCJrZXkiLCJyZXBsYWNlQXQiLCJub3JtYWxpemVWYWx1ZSIsImZpcmVPbkZpbmFsQ2hhbmdlIiwib25LZXlVcCIsIl9iIiwidHJhY2tMZW5ndGgiLCJpc1ZlcnRpY2FsIiwiZFgiLCJkWSIsImRlbHRhVmFsdWUiLCJhYnMiLCJzaWduIiwidGh1bWJWYWx1ZSIsIm5ld1ZhbHVlcyIsIm5ld1ZhbHVlIiwiYWxsb3dPdmVybGFwIiwib25FbmQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25GaW5hbENoYW5nZSIsInVwZGF0ZU1hcmtSZWZzIiwicmVuZGVyTWFyayIsIm51bU9mTWFya3MiLCJtYXJrUmVmcyIsImVsU3R5bGVzIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYWNrV2lkdGgiLCJwYXJzZUludCIsInRyYWNrSGVpZ2h0IiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nVG9wIiwicmVzIiwibWFya0hlaWdodCIsIm1hcmtXaWR0aCIsIm1hcmtSZWN0IiwicHVzaCIsInJvdW5kIiwiRXJyb3IiLCJzY2hkIiwiY29tcG9uZW50RGlkTW91bnQiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImNoZWNrSW5pdGlhbE92ZXJsYXAiLCJmb3JFYWNoIiwiY2hlY2tCb3VuZGFyaWVzIiwiaXNTdGVwRGl2aXNpYmxlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJvcHRpb25zIiwicmVuZGVyIiwicmVuZGVyVHJhY2siLCJyZW5kZXJUaHVtYiIsIl9jIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJjdXJzb3IiLCJvbk1vdXNlRG93biIsInZvaWRGbiIsIm9uVG91Y2hTdGFydCIsInJlZiIsImlzRHJhZ2dlZCIsIm9mZnNldCIsImFyciIsInBvc2l0aW9uIiwibWFyZ2luVG9wIiwibWFyZ2luTGVmdCIsInpJbmRleCIsInVzZXJTZWxlY3QiLCJ0b3VjaEFjdGlvbiIsIldlYmtpdFVzZXJTZWxlY3QiLCJNb3pVc2VyU2VsZWN0IiwibXNVc2VyU2VsZWN0IiwidGFiSW5kZXgiLCJkcmFnZ2FibGUiLCJyb2xlIiwiZGVmYXVsdFByb3BzIiwiQ29tcG9uZW50IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/Range.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.checkValuesAgainstBoundaries = exports.relativeValue = exports.useThumbOverlap = exports.Direction = exports.getTrackBackground = exports.Range = void 0;\nvar Range_1 = __importDefault(__webpack_require__(/*! ./Range */ \"(ssr)/./node_modules/react-range/lib/Range.js\"));\nexports.Range = Range_1.default;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-range/lib/utils.js\");\nObject.defineProperty(exports, \"getTrackBackground\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.getTrackBackground;\n    }\n}));\nObject.defineProperty(exports, \"useThumbOverlap\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.useThumbOverlap;\n    }\n}));\nObject.defineProperty(exports, \"relativeValue\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.relativeValue;\n    }\n}));\nObject.defineProperty(exports, \"checkValuesAgainstBoundaries\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.checkValuesAgainstBoundaries;\n    }\n}));\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nObject.defineProperty(exports, \"Direction\", ({\n    enumerable: true,\n    get: function() {\n        return types_1.Direction;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQ0FBb0MsR0FBR0EscUJBQXFCLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBR0EsMEJBQTBCLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQy9KLElBQUlRLFVBQVViLGdCQUFnQmMsbUJBQU9BLENBQUMsOERBQVM7QUFDL0NULGFBQWEsR0FBR1EsUUFBUUUsT0FBTztBQUMvQixJQUFJQyxVQUFVRixtQkFBT0EsQ0FBQyw4REFBUztBQUMvQlgsc0RBQXFEO0lBQUVjLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFFBQVFMLGtCQUFrQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ25JUixtREFBa0Q7SUFBRWMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUVAsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzdITixpREFBZ0Q7SUFBRWMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUVIsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3pITCxnRUFBK0Q7SUFBRWMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUVQsNEJBQTRCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkosSUFBSVksVUFBVUwsbUJBQU9BLENBQUMsOERBQVM7QUFDL0JYLDZDQUE0QztJQUFFYyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxRQUFRVCxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bnRpdGxlZDM2Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlL2xpYi9pbmRleC5qcz9jMTk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzID0gZXhwb3J0cy5yZWxhdGl2ZVZhbHVlID0gZXhwb3J0cy51c2VUaHVtYk92ZXJsYXAgPSBleHBvcnRzLkRpcmVjdGlvbiA9IGV4cG9ydHMuZ2V0VHJhY2tCYWNrZ3JvdW5kID0gZXhwb3J0cy5SYW5nZSA9IHZvaWQgMDtcbnZhciBSYW5nZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1JhbmdlXCIpKTtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZV8xLmRlZmF1bHQ7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0VHJhY2tCYWNrZ3JvdW5kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmdldFRyYWNrQmFja2dyb3VuZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZVRodW1iT3ZlcmxhcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS51c2VUaHVtYk92ZXJsYXA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWxhdGl2ZVZhbHVlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnJlbGF0aXZlVmFsdWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXM7IH0gfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlyZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkRpcmVjdGlvbjsgfSB9KTtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzIiwicmVsYXRpdmVWYWx1ZSIsInVzZVRodW1iT3ZlcmxhcCIsIkRpcmVjdGlvbiIsImdldFRyYWNrQmFja2dyb3VuZCIsIlJhbmdlIiwiUmFuZ2VfMSIsInJlcXVpcmUiLCJkZWZhdWx0IiwidXRpbHNfMSIsImVudW1lcmFibGUiLCJnZXQiLCJ0eXBlc18xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/types.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/types.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Direction = void 0;\nvar Direction;\n(function(Direction) {\n    Direction[\"Right\"] = \"to right\";\n    Direction[\"Left\"] = \"to left\";\n    Direction[\"Down\"] = \"to bottom\";\n    Direction[\"Up\"] = \"to top\";\n})(Direction = exports.Direction || (exports.Direction = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLElBQUlFO0FBQ0gsVUFBVUEsU0FBUztJQUNoQkEsU0FBUyxDQUFDLFFBQVEsR0FBRztJQUNyQkEsU0FBUyxDQUFDLE9BQU8sR0FBRztJQUNwQkEsU0FBUyxDQUFDLE9BQU8sR0FBRztJQUNwQkEsU0FBUyxDQUFDLEtBQUssR0FBRztBQUN0QixHQUFHQSxZQUFZRixRQUFRRSxTQUFTLElBQUtGLENBQUFBLGlCQUFpQixHQUFHLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bnRpdGxlZDM2Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlL2xpYi90eXBlcy5qcz9iNDEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXJlY3Rpb24gPSB2b2lkIDA7XG52YXIgRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICBEaXJlY3Rpb25bXCJSaWdodFwiXSA9IFwidG8gcmlnaHRcIjtcbiAgICBEaXJlY3Rpb25bXCJMZWZ0XCJdID0gXCJ0byBsZWZ0XCI7XG4gICAgRGlyZWN0aW9uW1wiRG93blwiXSA9IFwidG8gYm90dG9tXCI7XG4gICAgRGlyZWN0aW9uW1wiVXBcIl0gPSBcInRvIHRvcFwiO1xufSkoRGlyZWN0aW9uID0gZXhwb3J0cy5EaXJlY3Rpb24gfHwgKGV4cG9ydHMuRGlyZWN0aW9uID0ge30pKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRpcmVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __spreadArray = (void 0) && (void 0).__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nvar getStepDecimals = function(step) {\n    var decimals = step.toString().split(\".\")[1];\n    return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n    return event.touches && event.touches.length || event.changedTouches && event.changedTouches.length;\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    var precision = 8;\n    var roundedRes = Number(res.toFixed(precision));\n    return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value) return prev;\n        if (next && next < value) return next;\n    }\n    if (value > max) return max;\n    if (value < min) return min;\n    // `remainder` is a difference between the given value and a full step value\n    // that is closest lower to the given value and is in the range between the min value\n    // and the given value\n    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) % Math.floor(step * BIG_NUM);\n    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n    // Values with a remainder `< step/2` are rounded to the closest lower value\n    // while values with a remainder `= > step/2` are rounded to the closest bigger value\n    var res = Math.abs(remainder / BIG_NUM) < step / 2 ? rounded : rounded + step;\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\".concat(min, \") is equal/bigger than max (\").concat(max, \")\"));\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\".concat(value, \") is smaller than min (\").concat(min, \")\"));\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\".concat(value, \") is bigger than max (\").concat(max, \")\"));\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n    if (value < min) {\n        // set selectedValue to min\n        return min;\n    }\n    if (value > max) {\n        // set selectedValue to max\n        return max;\n    } else {\n        return value;\n    }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2) return;\n    if (!values.slice(1).every(function(item, i) {\n        return values[i] <= item;\n    })) {\n        throw new RangeError(\"values={[\".concat(values, \"]} needs to be sorted when allowOverlap={false}\"));\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"margin-top\"], 10),\n        bottom: parseInt(style[\"margin-bottom\"], 10),\n        left: parseInt(style[\"margin-left\"], 10),\n        right: parseInt(style[\"margin-right\"], 10)\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"padding-top\"], 10) + parseInt(style[\"border-top-width\"], 10),\n        bottom: parseInt(style[\"padding-bottom\"], 10) + parseInt(style[\"border-bottom-width\"], 10),\n        left: parseInt(style[\"padding-left\"], 10) + parseInt(style[\"border-left-width\"], 10),\n        right: parseInt(style[\"padding-right\"], 10) + parseInt(style[\"border-right-width\"], 10)\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function(element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */ function getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n    var thumbIndex = 0;\n    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n    for(var i = 1; i < thumbs.length; i++){\n        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n        if (thumbDistance < minThumbDistance) {\n            minThumbDistance = thumbDistance;\n            thumbIndex = i;\n        }\n    }\n    return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function(fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function() {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    } else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    // sort values ascending\n    var progress = values.slice(0).sort(function(a, b) {\n        return a - b;\n    }).map(function(value) {\n        return (value - min) / (max - min) * 100;\n    });\n    var middle = progress.reduce(function(acc, point, index) {\n        return \"\".concat(acc, \", \").concat(colors[index], \" \").concat(point, \"%, \").concat(colors[index + 1], \" \").concat(point, \"%\");\n    }, \"\");\n    return \"linear-gradient(\".concat(direction, \", \").concat(colors[0], \" 0%\").concat(middle, \", \").concat(colors[colors.length - 1], \" 100%)\");\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() {}\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */ var getThumbWidth = function(thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) {\n        valueToLabel = function(value) {\n            return value;\n        };\n    }\n    var width = Math.ceil(__spreadArray([\n        thumbEl\n    ], Array.from(thumbEl.children), true).reduce(function(width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */ if (el.innerText && el.innerText.includes(separator) && el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = \"hidden\";\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */ var getOverlaps = function(index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) {\n        valueToLabel = function(value) {\n            return value;\n        };\n    }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */ var buildOverlaps = function(thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */ offsets.forEach(function(_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex && (thumbX >= siblingX && thumbX <= siblingX + siblingWidth || thumbX + thumbXWidth >= siblingX && thumbX + thumbXWidth <= siblingX + siblingWidth)) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArray(__spreadArray([], overlaps, true), [\n                        thumbIndex,\n                        siblingIndex\n                    ], false);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */ var useThumbOverlap = function(rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) {\n        step = 0.1;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (valueToLabel === void 0) {\n        valueToLabel = function(value) {\n            return value;\n        };\n    }\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = (0, react_1.useState)({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = (0, react_1.useState)(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    (0, react_1.useEffect)(function() {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1) return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */ var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */ if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */ var offsetsX = overlaps.reduce(function(a, c, i, s) {\n                    return a.length ? __spreadArray(__spreadArray([], a, true), [\n                        offsets_1[s[i]].x\n                    ], false) : [\n                        offsets_1[s[i]].x\n                    ];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */ if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */ var labelValues_1 = [];\n                    overlaps.forEach(function(thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */ labelValue_1 = Array.from(new Set(labelValues_1.sort(function(a, b) {\n                        return parseFloat(a) - parseFloat(b);\n                    }))).map(valueToLabel).join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */ var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;\n                    newStyle.left = \"\".concat(Math.abs(first - (last + lastWidth)) / 2, \"px\");\n                    newStyle.transform = \"translate(-50%, 0)\";\n                } else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = \"hidden\";\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [\n        rangeRef,\n        values\n    ]);\n    return [\n        labelValue,\n        labelStyle\n    ];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */ function getThumbDistance(thumbEl, clientX, clientY, direction) {\n    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n    return isVertical(direction) ? Math.abs(clientY - (top + height / 2)) : Math.abs(clientX - (left + width / 2));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsZ0JBQWdCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsYUFBYSxJQUFLLFNBQVVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQ3hFLElBQUlBLFFBQVFDLFVBQVVDLE1BQU0sS0FBSyxHQUFHLElBQUssSUFBSUMsSUFBSSxHQUFHQyxJQUFJTCxLQUFLRyxNQUFNLEVBQUVHLElBQUlGLElBQUlDLEdBQUdELElBQUs7UUFDakYsSUFBSUUsTUFBTSxDQUFFRixDQUFBQSxLQUFLSixJQUFHLEdBQUk7WUFDcEIsSUFBSSxDQUFDTSxJQUFJQSxLQUFLQyxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDVixNQUFNLEdBQUdJO1lBQ2xERSxFQUFFLENBQUNGLEVBQUUsR0FBR0osSUFBSSxDQUFDSSxFQUFFO1FBQ25CO0lBQ0o7SUFDQSxPQUFPTCxHQUFHWSxNQUFNLENBQUNMLE1BQU1DLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNWO0FBQ3REO0FBQ0FZLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBR0EseUJBQXlCLEdBQUdBLGNBQWMsR0FBR0EsMEJBQTBCLEdBQUdBLGlCQUFpQixHQUFHQSxZQUFZLEdBQUdBLGlCQUFpQixHQUFHQSw0QkFBNEIsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSxpQkFBaUIsR0FBR0EsMkJBQTJCLEdBQUdBLG9DQUFvQyxHQUFHQSx1QkFBdUIsR0FBR0Esa0JBQWtCLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EsdUJBQXVCLEdBQUdBLG9CQUFvQixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQzNmLElBQUlzQixVQUFVQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUM3QixJQUFJQyxVQUFVRCxt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QU9uSixXQUFXdUMsYUFBYVgsS0FBS08sR0FBRyxDQUFDNEIsVUFBV2IsQ0FBQUEsTUFBTWlHLFNBQVMsTUFBTXZILEtBQUtPLEdBQUcsQ0FBQzJCLFVBQVdWLENBQUFBLE9BQU84QyxRQUFRO0FBQy9HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW50aXRsZWQzNi8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvdXRpbHMuanM/N2MyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXNlVGh1bWJPdmVybGFwID0gZXhwb3J0cy5hc3NlcnRVbnJlYWNoYWJsZSA9IGV4cG9ydHMudm9pZEZuID0gZXhwb3J0cy5nZXRUcmFja0JhY2tncm91bmQgPSBleHBvcnRzLnJlcGxhY2VBdCA9IGV4cG9ydHMuc2NoZCA9IGV4cG9ydHMudHJhbnNsYXRlID0gZXhwb3J0cy5nZXRDbG9zZXN0VGh1bWJJbmRleCA9IGV4cG9ydHMudHJhbnNsYXRlVGh1bWJzID0gZXhwb3J0cy5nZXRQYWRkaW5nQW5kQm9yZGVyID0gZXhwb3J0cy5nZXRNYXJnaW4gPSBleHBvcnRzLmNoZWNrSW5pdGlhbE92ZXJsYXAgPSBleHBvcnRzLmNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXMgPSBleHBvcnRzLmNoZWNrQm91bmRhcmllcyA9IGV4cG9ydHMuaXNWZXJ0aWNhbCA9IGV4cG9ydHMucmVsYXRpdmVWYWx1ZSA9IGV4cG9ydHMubm9ybWFsaXplVmFsdWUgPSBleHBvcnRzLmlzU3RlcERpdmlzaWJsZSA9IGV4cG9ydHMuaXNUb3VjaEV2ZW50ID0gZXhwb3J0cy5nZXRTdGVwRGVjaW1hbHMgPSB2b2lkIDA7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG52YXIgZ2V0U3RlcERlY2ltYWxzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICB2YXIgZGVjaW1hbHMgPSBzdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXTtcbiAgICByZXR1cm4gZGVjaW1hbHMgPyBkZWNpbWFscy5sZW5ndGggOiAwO1xufTtcbmV4cG9ydHMuZ2V0U3RlcERlY2ltYWxzID0gZ2V0U3RlcERlY2ltYWxzO1xuZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuICgoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCkgfHxcbiAgICAgICAgKGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkpO1xufVxuZXhwb3J0cy5pc1RvdWNoRXZlbnQgPSBpc1RvdWNoRXZlbnQ7XG5mdW5jdGlvbiBpc1N0ZXBEaXZpc2libGUobWluLCBtYXgsIHN0ZXApIHtcbiAgICB2YXIgcmVzID0gKG1heCAtIG1pbikgLyBzdGVwO1xuICAgIHZhciBwcmVjaXNpb24gPSA4O1xuICAgIHZhciByb3VuZGVkUmVzID0gTnVtYmVyKHJlcy50b0ZpeGVkKHByZWNpc2lvbikpO1xuICAgIHJldHVybiBwYXJzZUludChyb3VuZGVkUmVzLnRvU3RyaW5nKCksIDEwKSA9PT0gcm91bmRlZFJlcztcbn1cbmV4cG9ydHMuaXNTdGVwRGl2aXNpYmxlID0gaXNTdGVwRGl2aXNpYmxlO1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUsIGluZGV4LCBtaW4sIG1heCwgc3RlcCwgYWxsb3dPdmVybGFwLCB2YWx1ZXMpIHtcbiAgICB2YXIgQklHX05VTSA9IDEwZTEwO1xuICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIEJJR19OVU0pIC8gQklHX05VTTtcbiAgICBpZiAoIWFsbG93T3ZlcmxhcCkge1xuICAgICAgICB2YXIgcHJldiA9IHZhbHVlc1tpbmRleCAtIDFdO1xuICAgICAgICB2YXIgbmV4dCA9IHZhbHVlc1tpbmRleCArIDFdO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2ID4gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dCA8IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IG1heClcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICBpZiAodmFsdWUgPCBtaW4pXG4gICAgICAgIHJldHVybiBtaW47XG4gICAgLy8gYHJlbWFpbmRlcmAgaXMgYSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGdpdmVuIHZhbHVlIGFuZCBhIGZ1bGwgc3RlcCB2YWx1ZVxuICAgIC8vIHRoYXQgaXMgY2xvc2VzdCBsb3dlciB0byB0aGUgZ2l2ZW4gdmFsdWUgYW5kIGlzIGluIHRoZSByYW5nZSBiZXR3ZWVuIHRoZSBtaW4gdmFsdWVcbiAgICAvLyBhbmQgdGhlIGdpdmVuIHZhbHVlXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGguZmxvb3IodmFsdWUgKiBCSUdfTlVNIC0gbWluICogQklHX05VTSkgJVxuICAgICAgICBNYXRoLmZsb29yKHN0ZXAgKiBCSUdfTlVNKTtcbiAgICB2YXIgY2xvc2VzdExvd2VyTnVtID0gTWF0aC5mbG9vcih2YWx1ZSAqIEJJR19OVU0gLSBNYXRoLmFicyhyZW1haW5kZXIpKTtcbiAgICB2YXIgcm91bmRlZCA9IHJlbWFpbmRlciA9PT0gMCA/IHZhbHVlIDogY2xvc2VzdExvd2VyTnVtIC8gQklHX05VTTtcbiAgICAvLyBWYWx1ZXMgd2l0aCBhIHJlbWFpbmRlciBgPCBzdGVwLzJgIGFyZSByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IGxvd2VyIHZhbHVlXG4gICAgLy8gd2hpbGUgdmFsdWVzIHdpdGggYSByZW1haW5kZXIgYD0gPiBzdGVwLzJgIGFyZSByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IGJpZ2dlciB2YWx1ZVxuICAgIHZhciByZXMgPSBNYXRoLmFicyhyZW1haW5kZXIgLyBCSUdfTlVNKSA8IHN0ZXAgLyAyXG4gICAgICAgID8gcm91bmRlZFxuICAgICAgICA6IHJvdW5kZWQgKyBzdGVwO1xuICAgIHZhciBkZWNpbWFsUGxhY2VzID0gKDAsIGV4cG9ydHMuZ2V0U3RlcERlY2ltYWxzKShzdGVwKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChyZXMudG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplVmFsdWU7XG5mdW5jdGlvbiByZWxhdGl2ZVZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG59XG5leHBvcnRzLnJlbGF0aXZlVmFsdWUgPSByZWxhdGl2ZVZhbHVlO1xuZnVuY3Rpb24gaXNWZXJ0aWNhbChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5VcCB8fCBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkRvd247XG59XG5leHBvcnRzLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsO1xuZnVuY3Rpb24gY2hlY2tCb3VuZGFyaWVzKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIGlmIChtaW4gPj0gbWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibWluIChcIi5jb25jYXQobWluLCBcIikgaXMgZXF1YWwvYmlnZ2VyIHRoYW4gbWF4IChcIikuY29uY2F0KG1heCwgXCIpXCIpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidmFsdWUgKFwiLmNvbmNhdCh2YWx1ZSwgXCIpIGlzIHNtYWxsZXIgdGhhbiBtaW4gKFwiKS5jb25jYXQobWluLCBcIilcIikpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ2YWx1ZSAoXCIuY29uY2F0KHZhbHVlLCBcIikgaXMgYmlnZ2VyIHRoYW4gbWF4IChcIikuY29uY2F0KG1heCwgXCIpXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrQm91bmRhcmllcyA9IGNoZWNrQm91bmRhcmllcztcbmZ1bmN0aW9uIGNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXModmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIC8vIHNldCBzZWxlY3RlZFZhbHVlIHRvIG1pblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgLy8gc2V0IHNlbGVjdGVkVmFsdWUgdG8gbWF4XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzID0gY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcztcbmZ1bmN0aW9uIGNoZWNrSW5pdGlhbE92ZXJsYXAodmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCF2YWx1ZXMuc2xpY2UoMSkuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGkpIHsgcmV0dXJuIHZhbHVlc1tpXSA8PSBpdGVtOyB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInZhbHVlcz17W1wiLmNvbmNhdCh2YWx1ZXMsIFwiXX0gbmVlZHMgdG8gYmUgc29ydGVkIHdoZW4gYWxsb3dPdmVybGFwPXtmYWxzZX1cIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tJbml0aWFsT3ZlcmxhcCA9IGNoZWNrSW5pdGlhbE92ZXJsYXA7XG5mdW5jdGlvbiBnZXRNYXJnaW4oZWxlbWVudCkge1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcGFyc2VJbnQoc3R5bGVbJ21hcmdpbi10b3AnXSwgMTApLFxuICAgICAgICBib3R0b206IHBhcnNlSW50KHN0eWxlWydtYXJnaW4tYm90dG9tJ10sIDEwKSxcbiAgICAgICAgbGVmdDogcGFyc2VJbnQoc3R5bGVbJ21hcmdpbi1sZWZ0J10sIDEwKSxcbiAgICAgICAgcmlnaHQ6IHBhcnNlSW50KHN0eWxlWydtYXJnaW4tcmlnaHQnXSwgMTApXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0TWFyZ2luID0gZ2V0TWFyZ2luO1xuZnVuY3Rpb24gZ2V0UGFkZGluZ0FuZEJvcmRlcihlbGVtZW50KSB7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBwYXJzZUludChzdHlsZVsncGFkZGluZy10b3AnXSwgMTApICsgcGFyc2VJbnQoc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXSwgMTApLFxuICAgICAgICBib3R0b206IHBhcnNlSW50KHN0eWxlWydwYWRkaW5nLWJvdHRvbSddLCAxMCkgKyBwYXJzZUludChzdHlsZVsnYm9yZGVyLWJvdHRvbS13aWR0aCddLCAxMCksXG4gICAgICAgIGxlZnQ6IHBhcnNlSW50KHN0eWxlWydwYWRkaW5nLWxlZnQnXSwgMTApICsgcGFyc2VJbnQoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10sIDEwKSxcbiAgICAgICAgcmlnaHQ6IHBhcnNlSW50KHN0eWxlWydwYWRkaW5nLXJpZ2h0J10sIDEwKSArIHBhcnNlSW50KHN0eWxlWydib3JkZXItcmlnaHQtd2lkdGgnXSwgMTApLFxuICAgIH07XG59XG5leHBvcnRzLmdldFBhZGRpbmdBbmRCb3JkZXIgPSBnZXRQYWRkaW5nQW5kQm9yZGVyO1xuZnVuY3Rpb24gdHJhbnNsYXRlVGh1bWJzKGVsZW1lbnRzLCBvZmZzZXRzLCBydGwpIHtcbiAgICB2YXIgaW52ZXJ0ZXIgPSBydGwgPyAtMSA6IDE7XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZShlbGVtZW50LCBpbnZlcnRlciAqIG9mZnNldHNbaW5kZXhdLngsIG9mZnNldHNbaW5kZXhdLnkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy50cmFuc2xhdGVUaHVtYnMgPSB0cmFuc2xhdGVUaHVtYnM7XG4vKipcbiAqIFV0aWwgZnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIHRoZSBpbmRleCBvZiB0aGUgdGh1bWIgdGhhdCBpcyBjbG9zZXMgdG8gYSBnaXZlbiBwb3NpdGlvblxuICogQHBhcmFtIHRodW1icyAtIGFycmF5IG9mIFRodW1iIGVsZW1lbnQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tXG4gKiBAcGFyYW0gY2xpZW50WCAtIHRhcmdldCB4IHBvc2l0aW9uIChtb3VzZS90b3VjaClcbiAqIEBwYXJhbSBjbGllbnRZIC0gdGFyZ2V0IHkgcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGRpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYWNrXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RUaHVtYkluZGV4KHRodW1icywgY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIHRodW1iSW5kZXggPSAwO1xuICAgIHZhciBtaW5UaHVtYkRpc3RhbmNlID0gZ2V0VGh1bWJEaXN0YW5jZSh0aHVtYnNbMF0sIGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aHVtYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRodW1iRGlzdGFuY2UgPSBnZXRUaHVtYkRpc3RhbmNlKHRodW1ic1tpXSwgY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKHRodW1iRGlzdGFuY2UgPCBtaW5UaHVtYkRpc3RhbmNlKSB7XG4gICAgICAgICAgICBtaW5UaHVtYkRpc3RhbmNlID0gdGh1bWJEaXN0YW5jZTtcbiAgICAgICAgICAgIHRodW1iSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aHVtYkluZGV4O1xufVxuZXhwb3J0cy5nZXRDbG9zZXN0VGh1bWJJbmRleCA9IGdldENsb3Nlc3RUaHVtYkluZGV4O1xuZnVuY3Rpb24gdHJhbnNsYXRlKGVsZW1lbnQsIHgsIHkpIHtcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh4LCBcInB4LCBcIikuY29uY2F0KHksIFwicHgpXCIpO1xufVxuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FsZXhyZWFyZG9uL3JhZi1zY2hkXG52YXIgc2NoZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBsYXN0QXJncyA9IFtdO1xuICAgIHZhciBmcmFtZUlkID0gbnVsbDtcbiAgICB2YXIgd3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgICAgICAgZm4uYXBwbHkodm9pZCAwLCBsYXN0QXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHdyYXBwZXJGbjtcbn07XG5leHBvcnRzLnNjaGQgPSBzY2hkO1xuZnVuY3Rpb24gcmVwbGFjZUF0KHZhbHVlcywgaW5kZXgsIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlcy5zbGljZSgwKTtcbiAgICByZXRbaW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIHJldDtcbn1cbmV4cG9ydHMucmVwbGFjZUF0ID0gcmVwbGFjZUF0O1xuZnVuY3Rpb24gZ2V0VHJhY2tCYWNrZ3JvdW5kKF9hKSB7XG4gICAgdmFyIHZhbHVlcyA9IF9hLnZhbHVlcywgY29sb3JzID0gX2EuY29sb3JzLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heCwgX2IgPSBfYS5kaXJlY3Rpb24sIGRpcmVjdGlvbiA9IF9iID09PSB2b2lkIDAgPyB0eXBlc18xLkRpcmVjdGlvbi5SaWdodCA6IF9iLCBfYyA9IF9hLnJ0bCwgcnRsID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2M7XG4gICAgaWYgKHJ0bCAmJiBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0KSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJ0bCAmJiB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0KSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0O1xuICAgIH1cbiAgICAvLyBzb3J0IHZhbHVlcyBhc2NlbmRpbmdcbiAgICB2YXIgcHJvZ3Jlc3MgPSB2YWx1ZXMuc2xpY2UoMCkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICgodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbikpICogMTAwOyB9KTtcbiAgICB2YXIgbWlkZGxlID0gcHJvZ3Jlc3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBvaW50LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYWNjLCBcIiwgXCIpLmNvbmNhdChjb2xvcnNbaW5kZXhdLCBcIiBcIikuY29uY2F0KHBvaW50LCBcIiUsIFwiKS5jb25jYXQoY29sb3JzW2luZGV4ICsgMV0sIFwiIFwiKS5jb25jYXQocG9pbnQsIFwiJVwiKTtcbiAgICB9LCAnJyk7XG4gICAgcmV0dXJuIFwibGluZWFyLWdyYWRpZW50KFwiLmNvbmNhdChkaXJlY3Rpb24sIFwiLCBcIikuY29uY2F0KGNvbG9yc1swXSwgXCIgMCVcIikuY29uY2F0KG1pZGRsZSwgXCIsIFwiKS5jb25jYXQoY29sb3JzW2NvbG9ycy5sZW5ndGggLSAxXSwgXCIgMTAwJSlcIik7XG59XG5leHBvcnRzLmdldFRyYWNrQmFja2dyb3VuZCA9IGdldFRyYWNrQmFja2dyb3VuZDtcbmZ1bmN0aW9uIHZvaWRGbigpIHsgfVxuZXhwb3J0cy52b2lkRm4gPSB2b2lkRm47XG5mdW5jdGlvbiBhc3NlcnRVbnJlYWNoYWJsZSh4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkbid0IGV4cGVjdCB0byBnZXQgaGVyZVwiKTtcbn1cbmV4cG9ydHMuYXNzZXJ0VW5yZWFjaGFibGUgPSBhc3NlcnRVbnJlYWNoYWJsZTtcbi8qKlxuICogVXRpbCBmdW5jdGlvbiBmb3IgZ3JhYmJpbmcgdGhlIHRydWUgbGFyZ2VzdCB3aWR0aCBvZiBhIHRodW1iXG4gKiBpbmNsdWRpbmcgdGhlIGxhYmVsXG4gKiBAcGFyYW0gdGh1bWJFbCAtIFRodW1iIGVsZW1lbnQgdG8gZ3JhYiB0aGUgbGFyZ2VzdCB3aWR0aCBmcm9tXG4gKiBAcGFyYW0gdmFsdWUgLSBUaHVtYiB2YWx1ZSwgbm90IGxhYmVsIHZhbHVlXG4gKiBAcGFyYW0gc2VwYXJhdG9yIC0gTGFiZWwgc2VwYXJhdG9yIHZhbHVlXG4gKi9cbnZhciBnZXRUaHVtYldpZHRoID0gZnVuY3Rpb24gKHRodW1iRWwsIHZhbHVlLCBzZXBhcmF0b3IsIGRlY2ltYWxQbGFjZXMsIHZhbHVlVG9MYWJlbCkge1xuICAgIGlmICh2YWx1ZVRvTGFiZWwgPT09IHZvaWQgMCkgeyB2YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9OyB9XG4gICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKF9fc3ByZWFkQXJyYXkoW3RodW1iRWxdLCBBcnJheS5mcm9tKHRodW1iRWwuY2hpbGRyZW4pLCB0cnVlKS5yZWR1Y2UoZnVuY3Rpb24gKHdpZHRoLCBlbCkge1xuICAgICAgICB2YXIgZWxXaWR0aCA9IE1hdGguY2VpbChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIGxhYmVsIGNvbnRhaW5zIGEgbWVyZ2VkIGxhYmVsIHZhbHVlLCBpdCB3b24ndCByZXR1cm4gdGhlIHRydWVcbiAgICAgICAgICogbGFiZWwgd2lkdGggZm9yIHRoYXQgVGh1bWIuIENsb25lIHRoZSBsYWJlbCBhbmQgY2hhbmdlIHRoZSB2YWx1ZVxuICAgICAgICAgKiB0byB0aGF0IGluZGl2aWR1YWwgVGh1bWIgdmFsdWUgaW4gb3JkZXIgdG8gZ3JhYiB0aGUgdHJ1ZSB3aWR0aC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChlbC5pbm5lclRleHQgJiZcbiAgICAgICAgICAgIGVsLmlubmVyVGV4dC5pbmNsdWRlcyhzZXBhcmF0b3IpICYmXG4gICAgICAgICAgICBlbC5jaGlsZEVsZW1lbnRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGVsQ2xvbmUgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBlbENsb25lLmlubmVySFRNTCA9IHZhbHVlVG9MYWJlbCh2YWx1ZS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKTtcbiAgICAgICAgICAgIGVsQ2xvbmUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbENsb25lKTtcbiAgICAgICAgICAgIGVsV2lkdGggPSBNYXRoLmNlaWwoZWxDbG9uZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbFdpZHRoID4gd2lkdGggPyBlbFdpZHRoIDogd2lkdGg7XG4gICAgfSwgdGh1bWJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkpO1xuICAgIHJldHVybiB3aWR0aDtcbn07XG4vKipcbiAqIEJ1bGsgb2YgbG9naWMgZm9yIHRodW1iIG92ZXJsYXBzXG4gKiBDb25zaWRlciBhIHNjZW5hcmlvIHdpdGggNSB0aHVtYnM7XG4gKiBUaHVtYiAxIG92ZXJsYXBzIHdpdGggdGh1bWIgMCBhbmQgdGh1bWIgMlxuICogVGh1bWIgMiBvdmVybGFwcyB3aXRoIHRodW1iIDNcbiAqIFdlIG5lZWQgYW4gYXJyYXkgdGhhdCBjb250YWlucyBbMCwgMSwgMiwgM11cbiAqIFRoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gdGhlIGRpcmVjdGx5IG92ZXJsYXBwaW5nIHRodW1ic1xuICogYW5kIGFsbCB0aHVtYnMgb3ZlcmxhcHBpbmcgbGlua2VkIHRvIHRob3NlIGFuZCBzbyBvblxuICogQHBhcmFtIGluZGV4IC0gVGh1bWIgaW5kZXggY2FsY3VsYXRpbmcgb3ZlcmxhcHMgZm9yXG4gKiBAcGFyYW0gb2Zmc2V0cyAtIEN1cnJlbnQgQXJyYXkgb2YgVGh1bWIgb2Zmc2V0cyBmb3IgUmFuZ2VcbiAqIEBwYXJhbSB0aHVtYnMgLSBBcnJheSBvZiBUaHVtYiBlbGVtZW50c1xuICogQHBhcmFtIHZhbHVlcyAtIEFycmF5IG9mIFRodW1iIHZhbHVlc1xuICogQHBhcmFtIHNlcGFyYXRvciAtIFN0cmluZyBzZXBhcmF0b3IgZm9yIG1lcmdlZCBsYWJlbCB2YWx1ZXNcbiAqIEByZXR1cm5zIG92ZXJsYXBzIC0gQXJyYXkgb2YgYWxsIG92ZXJsYXBwaW5nIHRodW1icyBmcm9tIHRoZSBpbmRleFxuICovXG52YXIgZ2V0T3ZlcmxhcHMgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldHMsIHRodW1icywgdmFsdWVzLCBzZXBhcmF0b3IsIGRlY2ltYWxQbGFjZXMsIHZhbHVlVG9MYWJlbCkge1xuICAgIGlmICh2YWx1ZVRvTGFiZWwgPT09IHZvaWQgMCkgeyB2YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9OyB9XG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlIGZ1bmN0aW9uIGZvciBidWlsZGluZyB0aGUgb3ZlcmxhcHMgQXJyYXlcbiAgICAgKiBJZiBhbiBvdmVybGFwIGlzIGZvdW5kLCBmaW5kIHRoZSBvdmVybGFwcyBmb3IgdGhhdCBvdmVybGFwXG4gICAgICogQHBhcmFtIHRodW1iSW5kZXggY3VycmVudCBUaHVtYiBpbmRleCB0byBmaW5kIG92ZXJsYXBzIGZyb21cbiAgICAgKi9cbiAgICB2YXIgYnVpbGRPdmVybGFwcyA9IGZ1bmN0aW9uICh0aHVtYkluZGV4KSB7XG4gICAgICAgIHZhciB0aHVtYlhXaWR0aCA9IGdldFRodW1iV2lkdGgodGh1bWJzW3RodW1iSW5kZXhdLCB2YWx1ZXNbdGh1bWJJbmRleF0sIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKTtcbiAgICAgICAgdmFyIHRodW1iWCA9IG9mZnNldHNbdGh1bWJJbmRleF0ueDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgVGh1bWIgb2Zmc2V0cywgaWYgdGhlcmUgaXMgYSBtYXRjaFxuICAgICAgICAgKiBhZGQgdGhlIHRodW1iSW5kZXggYW5kIHNpYmxpbmdJbmRleCB0byB0aGUgb3ZlcmxhcHMgQXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlbiBidWlsZCBvdmVybGFwcyBmcm9tIHRoZSBvdmVybGFwcGluZyBzaWJsaW5nSW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHNpYmxpbmdJbmRleCkge1xuICAgICAgICAgICAgdmFyIHNpYmxpbmdYID0gX2EueDtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nV2lkdGggPSBnZXRUaHVtYldpZHRoKHRodW1ic1tzaWJsaW5nSW5kZXhdLCB2YWx1ZXNbc2libGluZ0luZGV4XSwgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpO1xuICAgICAgICAgICAgaWYgKHRodW1iSW5kZXggIT09IHNpYmxpbmdJbmRleCAmJlxuICAgICAgICAgICAgICAgICgodGh1bWJYID49IHNpYmxpbmdYICYmIHRodW1iWCA8PSBzaWJsaW5nWCArIHNpYmxpbmdXaWR0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRodW1iWCArIHRodW1iWFdpZHRoID49IHNpYmxpbmdYICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlggKyB0aHVtYlhXaWR0aCA8PSBzaWJsaW5nWCArIHNpYmxpbmdXaWR0aCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvdmVybGFwcy5pbmNsdWRlcyhzaWJsaW5nSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2godGh1bWJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2goc2libGluZ0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG92ZXJsYXBzLCB0cnVlKSwgW3RodW1iSW5kZXgsIHNpYmxpbmdJbmRleF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRPdmVybGFwcyhzaWJsaW5nSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBidWlsZE92ZXJsYXBzKGluZGV4KTtcbiAgICAvLyBTb3J0IGFuZCByZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSBidWlsdCBvdmVybGFwc1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQob3ZlcmxhcHMuc29ydCgpKSk7XG59O1xuLyoqXG4gKiBBIGN1c3RvbSBSZWFjdCBIb29rIGZvciBjYWxjdWxhdGluZyB3aGV0aGVyIGEgdGh1bWIgb3ZlcmxhcHNcbiAqIGFub3RoZXIgYW5kIHdoZXRoZXIgbGFiZWxzIGNvdWxkL3Nob3VsZCBtZXJnZS5cbiAqIEBwYXJhbSByYW5nZVJlZiAtIFJlYWN0IHJlZiB2YWx1ZSBvZiBSYW5nZSBjb21wb25lbnRcbiAqIEBwYXJhbSB2YWx1ZXMgLSBjdXJyZW50IFJhbmdlIHZhbHVlcyBBcnJheVxuICogQHBhcmFtIGluZGV4IC0gdGh1bWIgaW5kZXhcbiAqIEBwYXJhbSBzdGVwIC0gc3RlcCB2YWx1ZSwgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogQHBhcmFtIHNlcGFyYXRvciAtIHN0cmluZyB0byBzZXBhcmF0ZSB0aHVtYiB2YWx1ZXNcbiAqIEByZXR1cm5zIGxhYmVsIHZhbHVlICsgc3R5bGluZyBmb3IgdGh1bWIgbGFiZWxcbiAqL1xudmFyIHVzZVRodW1iT3ZlcmxhcCA9IGZ1bmN0aW9uIChyYW5nZVJlZiwgdmFsdWVzLCBpbmRleCwgc3RlcCwgc2VwYXJhdG9yLCB2YWx1ZVRvTGFiZWwpIHtcbiAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7IHN0ZXAgPSAwLjE7IH1cbiAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gJyAtICc7IH1cbiAgICBpZiAodmFsdWVUb0xhYmVsID09PSB2b2lkIDApIHsgdmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTsgfVxuICAgIHZhciBkZWNpbWFsUGxhY2VzID0gKDAsIGV4cG9ydHMuZ2V0U3RlcERlY2ltYWxzKShzdGVwKTtcbiAgICAvLyBDcmVhdGUgaW5pdGlhbCBsYWJlbCBzdHlsZSBhbmQgdmFsdWUuIExhYmVsIHZhbHVlIGRlZmF1bHRzIHRvIHRodW1iIHZhbHVlXG4gICAgdmFyIF9hID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHt9KSwgbGFiZWxTdHlsZSA9IF9hWzBdLCBzZXRMYWJlbFN0eWxlID0gX2FbMV07XG4gICAgdmFyIF9iID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHZhbHVlVG9MYWJlbCh2YWx1ZXNbaW5kZXhdLnRvRml4ZWQoZGVjaW1hbFBsYWNlcykpKSwgbGFiZWxWYWx1ZSA9IF9iWzBdLCBzZXRMYWJlbFZhbHVlID0gX2JbMV07XG4gICAgLy8gV2hlbiB0aGUgcmFuZ2VSZWYgb3IgdmFsdWVzIGNoYW5nZSwgdXBkYXRlIHRoZSBUaHVtYiBsYWJlbCB2YWx1ZXMgYW5kIHN0eWxpbmdcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgICAgICB2YXIgdGh1bWJzID0gcmFuZ2VSZWYuZ2V0VGh1bWJzKCk7XG4gICAgICAgICAgICBpZiAodGh1bWJzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5ld1N0eWxlID0ge307XG4gICAgICAgICAgICB2YXIgb2Zmc2V0c18xID0gcmFuZ2VSZWYuZ2V0T2Zmc2V0cygpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYW55IG92ZXJsYXBzIGZvciB0aGUgZ2l2ZW4gVGh1bWIgaW5kZXguIFRoaXMgbXVzdCByZXR1cm4gYWxsIGxpbmtlZFxuICAgICAgICAgICAgICogVGh1bWJzLiBTbyBpZiB0aGVyZSBhcmUgNCBUaHVtYnMgYW5kIFRodW1icyAyLCAzIGFuZCA0IG92ZXJsYXAuIElmIHdlIGFyZVxuICAgICAgICAgICAgICogZ2V0dGluZyB0aGUgb3ZlcmxhcHMgZm9yIFRodW1iIDEgYW5kIGl0IG92ZXJsYXBzIG9ubHkgVGh1bWIgMiwgd2UgbXVzdCBnZXRcbiAgICAgICAgICAgICAqIDIsIDMgYW5kIDQgYWxzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gZ2V0T3ZlcmxhcHMoaW5kZXgsIG9mZnNldHNfMSwgdGh1bWJzLCB2YWx1ZXMsIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKTtcbiAgICAgICAgICAgIC8vIFNldCBhIGRlZmF1bHQgbGFiZWwgdmFsdWUgb2YgdGhlIFRodW1iIHZhbHVlXG4gICAgICAgICAgICB2YXIgbGFiZWxWYWx1ZV8xID0gdmFsdWVUb0xhYmVsKHZhbHVlc1tpbmRleF0udG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlIGFyZSBvdmVybGFwcyBmb3IgdGhlIFRodW1iLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICogTGFiZWwgdmFsdWUgYWxvbmcgd2l0aCB0aGUgcmVsZXZhbnQgc3R5bGluZy4gV2Ugb25seSB3YW50IHRvIHNob3cgYSBMYWJlbFxuICAgICAgICAgICAgICogZm9yIHRoZSBsZWZ0IG1vc3QgVGh1bWIgaW4gYW4gb3ZlcmxhcHBpbmcgc2V0LlxuICAgICAgICAgICAgICogQWxsIG90aGVyIFRodW1icyB3aWxsIGJlIHNldCB0byBkaXNwbGF5OiBub25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAob3ZlcmxhcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogR2V0IGFuIEFycmF5IG9mIHRoZSBvZmZzZXRzIGZvciB0aGUgb3ZlcmxhcHBpbmcgVGh1bWJzXG4gICAgICAgICAgICAgICAgICogVGhpcyBpcyBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGlmIHRoZSBUaHVtYiB3ZSBhcmUgbG9va2luZyBhdFxuICAgICAgICAgICAgICAgICAqIGlzIHRoZSBsZWZ0IG1vc3QgdGh1bWIgaW4gYW4gb3ZlcmxhcHBpbmcgc2V0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldHNYID0gb3ZlcmxhcHMucmVkdWNlKGZ1bmN0aW9uIChhLCBjLCBpLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA/IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYSwgdHJ1ZSksIFtvZmZzZXRzXzFbc1tpXV0ueF0sIGZhbHNlKSA6IFtvZmZzZXRzXzFbc1tpXV0ueF07XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIG91ciBUaHVtYiBpcyB0aGUgbGVmdCBtb3N0IFRodW1iLCB3ZSBjYW4gYnVpbGQgYSBMYWJlbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAqIGFuZCBzZXQgdGhlIHN0eWxlIGZvciB0aGF0IExhYmVsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWluLmFwcGx5KE1hdGgsIG9mZnNldHNYKSA9PT0gb2Zmc2V0c18xW2luZGV4XS54KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBGaXJzdCBjYWxjdWxhdGUgdGhlIExhYmVsIHZhbHVlLiBUbyBkbyB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgKiBncmFiIGFsbCB0aGUgdmFsdWVzIGZvciB0aGUgVGh1bWJzIGluIG91ciBvdmVybGFwcy5cbiAgICAgICAgICAgICAgICAgICAgICogVGhlbiBjb252ZXJ0IHRoYXQgdG8gYSBTZXQgYW5kIHNvcnQgaXQgd2hpbHN0IHJlbW92aW5nIGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxWYWx1ZXNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcy5mb3JFYWNoKGZ1bmN0aW9uICh0aHVtYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxWYWx1ZXNfMS5wdXNoKHZhbHVlc1t0aHVtYl0udG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogIFVwZGF0ZSB0aGUgbGFiZWxWYWx1ZSB3aXRoIHRoZSByZXN1bHRpbmcgQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICogIGpvaW5lZCBieSBvdXIgZGVmaW5lZCBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVmFsdWVfMSA9IEFycmF5LmZyb20obmV3IFNldChsYWJlbFZhbHVlc18xLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHBhcnNlRmxvYXQoYSkgLSBwYXJzZUZsb2F0KGIpOyB9KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKHZhbHVlVG9MYWJlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBMYXN0bHksIGJ1aWxkIHRoZSBsYWJlbCBzdHlsaW5nLiBUaGUgbGFiZWwgc3R5bGluZyB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAqIHBvc2l0aW9uIHRoZSBsYWJlbCBhbmQgYXBwbHkgYSB0cmFuc2Zvcm0gc28gdGhhdCBpdCdzIGNlbnRlcmVkLlxuICAgICAgICAgICAgICAgICAgICAgKiBXZSB3YW50IHRoZSBjZW50ZXIgcG9pbnQgYmV0d2VlbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBsZWZ0IG1vc3QgVGh1bWJcbiAgICAgICAgICAgICAgICAgICAgICogYW5kIHRoZSByaWdodCBlZGdlIG9mIHRoZSByaWdodCBtb3N0IFRodW1iLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2Zmc2V0c1gpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIG9mZnNldHNYKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RXaWR0aCA9IHRodW1ic1tvdmVybGFwc1tvZmZzZXRzWC5pbmRleE9mKGxhc3QpXV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChNYXRoLmFicyhmaXJzdCAtIChsYXN0ICsgbGFzdFdpZHRoKSkgLyAyLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC01MCUsIDApJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBUaHVtYiBpc24ndCB0aGUgbGVmdCBtb3N0IFRodW1iLCBoaWRlIHRoZSBMYWJlbCFcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFiZWwgdmFsdWUgYW5kIHN0eWxlXG4gICAgICAgICAgICBzZXRMYWJlbFZhbHVlKGxhYmVsVmFsdWVfMSk7XG4gICAgICAgICAgICBzZXRMYWJlbFN0eWxlKG5ld1N0eWxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtyYW5nZVJlZiwgdmFsdWVzXSk7XG4gICAgcmV0dXJuIFtsYWJlbFZhbHVlLCBsYWJlbFN0eWxlXTtcbn07XG5leHBvcnRzLnVzZVRodW1iT3ZlcmxhcCA9IHVzZVRodW1iT3ZlcmxhcDtcbi8qKlxuICogVXRpbCBmdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgdGhlIGRpc3RhbmNlIG9mIHRoZSBjZW50ZXIgb2YgYSB0aHVtYlxuICogZm9ybSBhIGdpdmVuIG1vdXNlL3RvdWNoIHRhcmdldCdzIHBvc2l0aW9uXG4gKiBAcGFyYW0gdGh1bWJFbCAtIFRodW1iIGVsZW1lbnQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tXG4gKiBAcGFyYW0gY2xpZW50WCAtIHRhcmdldCB4IHBvc2l0aW9uIChtb3VzZS90b3VjaClcbiAqIEBwYXJhbSBjbGllbnRZIC0gdGFyZ2V0IHkgcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGRpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYWNrXG4gKi9cbmZ1bmN0aW9uIGdldFRodW1iRGlzdGFuY2UodGh1bWJFbCwgY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIF9hID0gdGh1bWJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcCwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgIHJldHVybiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBNYXRoLmFicyhjbGllbnRZIC0gKHRvcCArIGhlaWdodCAvIDIpKSA6IE1hdGguYWJzKGNsaWVudFggLSAobGVmdCArIHdpZHRoIC8gMikpO1xufVxuIl0sIm5hbWVzIjpbIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJwYWNrIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaSIsImwiLCJhciIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiY29uY2F0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VUaHVtYk92ZXJsYXAiLCJhc3NlcnRVbnJlYWNoYWJsZSIsInZvaWRGbiIsImdldFRyYWNrQmFja2dyb3VuZCIsInJlcGxhY2VBdCIsInNjaGQiLCJ0cmFuc2xhdGUiLCJnZXRDbG9zZXN0VGh1bWJJbmRleCIsInRyYW5zbGF0ZVRodW1icyIsImdldFBhZGRpbmdBbmRCb3JkZXIiLCJnZXRNYXJnaW4iLCJjaGVja0luaXRpYWxPdmVybGFwIiwiY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyIsImNoZWNrQm91bmRhcmllcyIsImlzVmVydGljYWwiLCJyZWxhdGl2ZVZhbHVlIiwibm9ybWFsaXplVmFsdWUiLCJpc1N0ZXBEaXZpc2libGUiLCJpc1RvdWNoRXZlbnQiLCJnZXRTdGVwRGVjaW1hbHMiLCJyZWFjdF8xIiwicmVxdWlyZSIsInR5cGVzXzEiLCJzdGVwIiwiZGVjaW1hbHMiLCJ0b1N0cmluZyIsInNwbGl0IiwiZXZlbnQiLCJ0b3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJtaW4iLCJtYXgiLCJyZXMiLCJwcmVjaXNpb24iLCJyb3VuZGVkUmVzIiwiTnVtYmVyIiwidG9GaXhlZCIsInBhcnNlSW50IiwiaW5kZXgiLCJhbGxvd092ZXJsYXAiLCJ2YWx1ZXMiLCJCSUdfTlVNIiwiTWF0aCIsInJvdW5kIiwicHJldiIsIm5leHQiLCJyZW1haW5kZXIiLCJmbG9vciIsImNsb3Nlc3RMb3dlck51bSIsImFicyIsInJvdW5kZWQiLCJkZWNpbWFsUGxhY2VzIiwicGFyc2VGbG9hdCIsImRpcmVjdGlvbiIsIkRpcmVjdGlvbiIsIlVwIiwiRG93biIsIlJhbmdlRXJyb3IiLCJldmVyeSIsIml0ZW0iLCJlbGVtZW50Iiwic3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiZWxlbWVudHMiLCJvZmZzZXRzIiwicnRsIiwiaW52ZXJ0ZXIiLCJmb3JFYWNoIiwieCIsInkiLCJ0aHVtYnMiLCJjbGllbnRYIiwiY2xpZW50WSIsInRodW1iSW5kZXgiLCJtaW5UaHVtYkRpc3RhbmNlIiwiZ2V0VGh1bWJEaXN0YW5jZSIsInRodW1iRGlzdGFuY2UiLCJ0cmFuc2Zvcm0iLCJmbiIsImxhc3RBcmdzIiwiZnJhbWVJZCIsIndyYXBwZXJGbiIsImFyZ3MiLCJfaSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFwcGx5IiwicmV0IiwiX2EiLCJjb2xvcnMiLCJfYiIsIlJpZ2h0IiwiX2MiLCJMZWZ0IiwicHJvZ3Jlc3MiLCJzb3J0IiwiYSIsImIiLCJtYXAiLCJtaWRkbGUiLCJyZWR1Y2UiLCJhY2MiLCJwb2ludCIsIkVycm9yIiwiZ2V0VGh1bWJXaWR0aCIsInRodW1iRWwiLCJzZXBhcmF0b3IiLCJ2YWx1ZVRvTGFiZWwiLCJ3aWR0aCIsImNlaWwiLCJjaGlsZHJlbiIsImVsIiwiZWxXaWR0aCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImlubmVyVGV4dCIsImluY2x1ZGVzIiwiY2hpbGRFbGVtZW50Q291bnQiLCJlbENsb25lIiwiY2xvbmVOb2RlIiwiaW5uZXJIVE1MIiwidmlzaWJpbGl0eSIsImRvY3VtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJnZXRPdmVybGFwcyIsIm92ZXJsYXBzIiwiYnVpbGRPdmVybGFwcyIsInRodW1iWFdpZHRoIiwidGh1bWJYIiwic2libGluZ0luZGV4Iiwic2libGluZ1giLCJzaWJsaW5nV2lkdGgiLCJwdXNoIiwiU2V0IiwicmFuZ2VSZWYiLCJ1c2VTdGF0ZSIsImxhYmVsU3R5bGUiLCJzZXRMYWJlbFN0eWxlIiwibGFiZWxWYWx1ZSIsInNldExhYmVsVmFsdWUiLCJ1c2VFZmZlY3QiLCJnZXRUaHVtYnMiLCJuZXdTdHlsZSIsIm9mZnNldHNfMSIsImdldE9mZnNldHMiLCJsYWJlbFZhbHVlXzEiLCJvZmZzZXRzWCIsImMiLCJzIiwibGFiZWxWYWx1ZXNfMSIsInRodW1iIiwiam9pbiIsImZpcnN0IiwibGFzdCIsImxhc3RXaWR0aCIsImluZGV4T2YiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/utils.js\n");

/***/ })

};
;