/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CFeaturedHomes.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CFeaturedHomesAlt.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CLocationSelect.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CPropertyType.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CReactRange.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Cimage-component.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Cpublic%5Cimg%5Chome%5Cgray-sofa-white-living-room-interior-with-copy-space-3d-rendering%201.svg&server=false!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CFeaturedHomes.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CFeaturedHomesAlt.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CLocationSelect.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CPropertyType.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CReactRange.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Cimage-component.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Cpublic%5Cimg%5Chome%5Cgray-sofa-white-living-room-interior-with-copy-space-3d-rendering%201.svg&server=false! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/FeaturedHomes.js */ \"(app-pages-browser)/./components/FeaturedHomes.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/FeaturedHomesAlt.js */ \"(app-pages-browser)/./components/FeaturedHomesAlt.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/LocationSelect.js */ \"(app-pages-browser)/./components/LocationSelect.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/PropertyType.js */ \"(app-pages-browser)/./components/PropertyType.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/ReactRange.js */ \"(app-pages-browser)/./components/ReactRange.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/image-component.js */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./public/img/home/gray-sofa-white-living-room-interior-with-copy-space-3d-rendering 1.svg */ \"(app-pages-browser)/./public/img/home/gray-sofa-white-living-room-interior-with-copy-space-3d-rendering 1.svg\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNlbXJlbCU1Q09uZURyaXZlJTVDTWFzYSVDMyVCQ3N0JUMzJUJDJTVDYnViaXRlY2VrJTVDY29tcG9uZW50cyU1Q0ZlYXR1cmVkSG9tZXMuanMmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNlbXJlbCU1Q09uZURyaXZlJTVDTWFzYSVDMyVCQ3N0JUMzJUJDJTVDYnViaXRlY2VrJTVDY29tcG9uZW50cyU1Q0ZlYXR1cmVkSG9tZXNBbHQuanMmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNlbXJlbCU1Q09uZURyaXZlJTVDTWFzYSVDMyVCQ3N0JUMzJUJDJTVDYnViaXRlY2VrJTVDY29tcG9uZW50cyU1Q0xvY2F0aW9uU2VsZWN0LmpzJm1vZHVsZXM9QyUzQSU1Q1VzZXJzJTVDZW1yZWwlNUNPbmVEcml2ZSU1Q01hc2ElQzMlQkNzdCVDMyVCQyU1Q2J1Yml0ZWNlayU1Q2NvbXBvbmVudHMlNUNQcm9wZXJ0eVR5cGUuanMmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNlbXJlbCU1Q09uZURyaXZlJTVDTWFzYSVDMyVCQ3N0JUMzJUJDJTVDYnViaXRlY2VrJTVDY29tcG9uZW50cyU1Q1JlYWN0UmFuZ2UuanMmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNlbXJlbCU1Q09uZURyaXZlJTVDTWFzYSVDMyVCQ3N0JUMzJUJDJTVDYnViaXRlY2VrJTVDbm9kZV9tb2R1bGVzJTVDbmV4dCU1Q2Rpc3QlNUNjbGllbnQlNUNpbWFnZS1jb21wb25lbnQuanMmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNlbXJlbCU1Q09uZURyaXZlJTVDTWFzYSVDMyVCQ3N0JUMzJUJDJTVDYnViaXRlY2VrJTVDcHVibGljJTVDaW1nJTVDaG9tZSU1Q2dyYXktc29mYS13aGl0ZS1saXZpbmctcm9vbS1pbnRlcmlvci13aXRoLWNvcHktc3BhY2UtM2QtcmVuZGVyaW5nJTIwMS5zdmcmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxvTEFBa0g7QUFDbEgsMExBQXFIO0FBQ3JILHNMQUFtSDtBQUNuSCxrTEFBaUg7QUFDakgsOEtBQStHO0FBQy9HLG9PQUEwSTtBQUMxSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2I1MjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxlbXJlbFxcXFxPbmVEcml2ZVxcXFxNYXNhw7xzdMO8XFxcXGJ1Yml0ZWNla1xcXFxjb21wb25lbnRzXFxcXEZlYXR1cmVkSG9tZXMuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXGVtcmVsXFxcXE9uZURyaXZlXFxcXE1hc2HDvHN0w7xcXFxcYnViaXRlY2VrXFxcXGNvbXBvbmVudHNcXFxcRmVhdHVyZWRIb21lc0FsdC5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcZW1yZWxcXFxcT25lRHJpdmVcXFxcTWFzYcO8c3TDvFxcXFxidWJpdGVjZWtcXFxcY29tcG9uZW50c1xcXFxMb2NhdGlvblNlbGVjdC5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcZW1yZWxcXFxcT25lRHJpdmVcXFxcTWFzYcO8c3TDvFxcXFxidWJpdGVjZWtcXFxcY29tcG9uZW50c1xcXFxQcm9wZXJ0eVR5cGUuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXGVtcmVsXFxcXE9uZURyaXZlXFxcXE1hc2HDvHN0w7xcXFxcYnViaXRlY2VrXFxcXGNvbXBvbmVudHNcXFxcUmVhY3RSYW5nZS5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcZW1yZWxcXFxcT25lRHJpdmVcXFxcTWFzYcO8c3TDvFxcXFxidWJpdGVjZWtcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcaW1hZ2UtY29tcG9uZW50LmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxlbXJlbFxcXFxPbmVEcml2ZVxcXFxNYXNhw7xzdMO8XFxcXGJ1Yml0ZWNla1xcXFxwdWJsaWNcXFxcaW1nXFxcXGhvbWVcXFxcZ3JheS1zb2ZhLXdoaXRlLWxpdmluZy1yb29tLWludGVyaW9yLXdpdGgtY29weS1zcGFjZS0zZC1yZW5kZXJpbmcgMS5zdmdcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CFeaturedHomes.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CFeaturedHomesAlt.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CLocationSelect.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CPropertyType.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Ccomponents%5CReactRange.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Cimage-component.js&modules=C%3A%5CUsers%5Cemrel%5COneDrive%5CMasa%C3%BCst%C3%BC%5Cbubitecek%5Cpublic%5Cimg%5Chome%5Cgray-sofa-white-living-room-interior-with-copy-space-3d-rendering%201.svg&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-range/lib/Range.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/Range.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __extends = (void 0) && (void 0).__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (void 0) && (void 0).__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __importStar(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/react-range/lib/utils.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/react-range/lib/types.js\");\nvar INCREASE_KEYS = [\n    \"ArrowRight\",\n    \"ArrowUp\",\n    \"k\",\n    \"PageUp\"\n];\nvar DECREASE_KEYS = [\n    \"ArrowLeft\",\n    \"ArrowDown\",\n    \"j\",\n    \"PageDown\"\n];\nvar Range = /** @class */ function(_super) {\n    __extends(Range, _super);\n    function Range(props) {\n        var _this = _super.call(this, props) || this;\n        _this.trackRef = React.createRef();\n        _this.thumbRefs = [];\n        _this.state = {\n            draggedTrackPos: [\n                -1,\n                -1\n            ],\n            draggedThumbIndex: -1,\n            thumbZIndexes: new Array(_this.props.values.length).fill(0).map(function(t, i) {\n                return i;\n            }),\n            isChanged: false,\n            markOffsets: []\n        };\n        _this.getOffsets = function() {\n            var _a = _this.props, direction = _a.direction, values = _a.values, min = _a.min, max = _a.max;\n            var trackElement = _this.trackRef.current;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackPadding = (0, utils_1.getPaddingAndBorder)(trackElement);\n            return _this.getThumbs().map(function(thumb, index) {\n                var thumbOffsets = {\n                    x: 0,\n                    y: 0\n                };\n                var thumbRect = thumb.getBoundingClientRect();\n                var thumbMargins = (0, utils_1.getMargin)(thumb);\n                switch(direction){\n                    case types_1.Direction.Right:\n                        thumbOffsets.x = (thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y = ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x += trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) - thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Left:\n                        thumbOffsets.x = (thumbMargins.right + trackPadding.right) * -1;\n                        thumbOffsets.y = ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x += trackRect.width - trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) - thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Up:\n                        thumbOffsets.x = ((thumbRect.width - trackRect.width) / 2 + thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y += trackRect.height - trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) - thumbRect.height / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Down:\n                        thumbOffsets.x = ((thumbRect.width - trackRect.width) / 2 + thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y += trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) - thumbRect.height / 2;\n                        return thumbOffsets;\n                    default:\n                        return (0, utils_1.assertUnreachable)(direction);\n                }\n            });\n        };\n        _this.getThumbs = function() {\n            if (_this.trackRef && _this.trackRef.current) {\n                return Array.from(_this.trackRef.current.children).filter(function(el) {\n                    return el.hasAttribute(\"aria-valuenow\");\n                });\n            }\n            console.warn(\"No thumbs found in the track container. Did you forget to pass & spread the `props` param in renderTrack?\");\n            return [];\n        };\n        _this.getTargetIndex = function(e) {\n            return _this.getThumbs().findIndex(function(child) {\n                return child === e.target || child.contains(e.target);\n            });\n        };\n        _this.addTouchEvents = function(e) {\n            document.addEventListener(\"touchmove\", _this.schdOnTouchMove, {\n                passive: false\n            });\n            document.addEventListener(\"touchend\", _this.schdOnEnd, {\n                passive: false\n            });\n            document.addEventListener(\"touchcancel\", _this.schdOnEnd, {\n                passive: false\n            });\n        };\n        _this.addMouseEvents = function(e) {\n            document.addEventListener(\"mousemove\", _this.schdOnMouseMove);\n            document.addEventListener(\"mouseup\", _this.schdOnEnd);\n        };\n        _this.onMouseDownTrack = function(e) {\n            var _a;\n            if (e.button !== 0) return;\n            e.persist();\n            e.preventDefault();\n            _this.addMouseEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function(thumbRef) {\n                    var _a;\n                    return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target);\n                })) return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [\n                        e.clientX,\n                        e.clientY\n                    ]\n                }, function() {\n                    return _this.onMove(e.clientX, e.clientY);\n                });\n            } else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function(t) {\n                    return t.current;\n                }), e.clientX, e.clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex\n                }, function() {\n                    return _this.onMove(e.clientX, e.clientY);\n                });\n            }\n        };\n        _this.onResize = function() {\n            (0, utils_1.translateThumbs)(_this.getThumbs(), _this.getOffsets(), _this.props.rtl);\n            _this.calculateMarkOffsets();\n        };\n        _this.onTouchStartTrack = function(e) {\n            var _a;\n            e.persist();\n            _this.addTouchEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function(thumbRef) {\n                    var _a;\n                    return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target);\n                })) return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [\n                        e.touches[0].clientX,\n                        e.touches[0].clientY\n                    ]\n                }, function() {\n                    return _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n                });\n            } else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function(t) {\n                    return t.current;\n                }), e.touches[0].clientX, e.touches[0].clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex\n                }, function() {\n                    return _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n                });\n            }\n        };\n        _this.onMouseOrTouchStart = function(e) {\n            if (_this.props.disabled) return;\n            var isTouch = (0, utils_1.isTouchEvent)(e);\n            if (!isTouch && e.button !== 0) return;\n            var index = _this.getTargetIndex(e);\n            if (index === -1) return;\n            if (isTouch) {\n                _this.addTouchEvents(e);\n            } else {\n                _this.addMouseEvents(e);\n            }\n            _this.setState({\n                draggedThumbIndex: index,\n                thumbZIndexes: _this.state.thumbZIndexes.map(function(t, i) {\n                    if (i === index) {\n                        return Math.max.apply(Math, _this.state.thumbZIndexes);\n                    }\n                    return t <= _this.state.thumbZIndexes[index] ? t : t - 1;\n                })\n            });\n        };\n        _this.onMouseMove = function(e) {\n            e.preventDefault();\n            _this.onMove(e.clientX, e.clientY);\n        };\n        _this.onTouchMove = function(e) {\n            e.preventDefault();\n            _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n        };\n        _this.onKeyDown = function(e) {\n            var _a = _this.props, values = _a.values, onChange = _a.onChange, step = _a.step, rtl = _a.rtl, direction = _a.direction;\n            var isChanged = _this.state.isChanged;\n            var index = _this.getTargetIndex(e.nativeEvent);\n            var inverter = rtl || direction === types_1.Direction.Left || direction === types_1.Direction.Down ? -1 : 1;\n            if (index === -1) return;\n            if (INCREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] + inverter * (e.key === \"PageUp\" ? step * 10 : step), index)));\n            } else if (DECREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] - inverter * (e.key === \"PageDown\" ? step * 10 : step), index)));\n            } else if (e.key === \"Tab\") {\n                _this.setState({\n                    draggedThumbIndex: -1\n                }, function() {\n                    // If key pressed when thumb was moving, fire onFinalChange\n                    if (isChanged) {\n                        _this.fireOnFinalChange();\n                    }\n                });\n            } else {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            }\n        };\n        _this.onKeyUp = function(e) {\n            var isChanged = _this.state.isChanged;\n            _this.setState({\n                draggedThumbIndex: -1\n            }, function() {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            });\n        };\n        _this.onMove = function(clientX, clientY) {\n            var _a = _this.state, draggedThumbIndex = _a.draggedThumbIndex, draggedTrackPos = _a.draggedTrackPos;\n            var _b = _this.props, direction = _b.direction, min = _b.min, max = _b.max, onChange = _b.onChange, values = _b.values, step = _b.step, rtl = _b.rtl;\n            if (draggedThumbIndex === -1 && draggedTrackPos[0] === -1 && draggedTrackPos[1] === -1) return null;\n            var trackElement = _this.trackRef.current;\n            // If component was closed down prematurely, A last onMove could be triggered based on requestAnimationFrame()\n            if (!trackElement) return null;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackLength = (0, utils_1.isVertical)(direction) ? trackRect.height : trackRect.width;\n            if (draggedTrackPos[0] !== -1 && draggedTrackPos[1] !== -1) {\n                // calculate how much it moved since the last update\n                var dX = clientX - draggedTrackPos[0];\n                var dY = clientY - draggedTrackPos[1];\n                // calculate the delta of the value\n                var deltaValue = 0;\n                switch(direction){\n                    case types_1.Direction.Right:\n                    case types_1.Direction.Left:\n                        deltaValue = dX / trackLength * (max - min);\n                        break;\n                    case types_1.Direction.Down:\n                    case types_1.Direction.Up:\n                        deltaValue = dY / trackLength * (max - min);\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    deltaValue *= -1;\n                }\n                if (Math.abs(deltaValue) >= step / 2) {\n                    // adjust delta so it fits into the range\n                    for(var i = 0; i < _this.thumbRefs.length; i++){\n                        if (values[i] === max && Math.sign(deltaValue) === 1 || values[i] === min && Math.sign(deltaValue) === -1) return;\n                        var thumbValue = values[i] + deltaValue;\n                        if (thumbValue > max) deltaValue = max - values[i];\n                        else if (thumbValue < min) deltaValue = min - values[i];\n                    }\n                    // add the delta to each thumb\n                    var newValues = values.slice(0);\n                    for(var i = 0; i < _this.thumbRefs.length; i++){\n                        newValues = (0, utils_1.replaceAt)(newValues, i, _this.normalizeValue(values[i] + deltaValue, i));\n                    }\n                    _this.setState({\n                        draggedTrackPos: [\n                            clientX,\n                            clientY\n                        ]\n                    });\n                    onChange(newValues);\n                }\n            } else {\n                var newValue = 0;\n                switch(direction){\n                    case types_1.Direction.Right:\n                        newValue = (clientX - trackRect.left) / trackLength * (max - min) + min;\n                        break;\n                    case types_1.Direction.Left:\n                        newValue = (trackLength - (clientX - trackRect.left)) / trackLength * (max - min) + min;\n                        break;\n                    case types_1.Direction.Down:\n                        newValue = (clientY - trackRect.top) / trackLength * (max - min) + min;\n                        break;\n                    case types_1.Direction.Up:\n                        newValue = (trackLength - (clientY - trackRect.top)) / trackLength * (max - min) + min;\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    newValue = max + min - newValue;\n                }\n                if (Math.abs(values[draggedThumbIndex] - newValue) >= step / 2) {\n                    onChange((0, utils_1.replaceAt)(values, draggedThumbIndex, _this.normalizeValue(newValue, draggedThumbIndex)));\n                }\n            }\n        };\n        _this.normalizeValue = function(value, index) {\n            var _a = _this.props, min = _a.min, max = _a.max, step = _a.step, allowOverlap = _a.allowOverlap, values = _a.values;\n            return (0, utils_1.normalizeValue)(value, index, min, max, step, allowOverlap, values);\n        };\n        _this.onEnd = function(e) {\n            e.preventDefault();\n            document.removeEventListener(\"mousemove\", _this.schdOnMouseMove);\n            document.removeEventListener(\"touchmove\", _this.schdOnTouchMove);\n            document.removeEventListener(\"mouseup\", _this.schdOnEnd);\n            document.removeEventListener(\"touchend\", _this.schdOnEnd);\n            document.removeEventListener(\"touchcancel\", _this.schdOnEnd);\n            if (_this.state.draggedThumbIndex === -1 && _this.state.draggedTrackPos[0] === -1 && _this.state.draggedTrackPos[1] === -1) return null;\n            _this.setState({\n                draggedThumbIndex: -1,\n                draggedTrackPos: [\n                    -1,\n                    -1\n                ]\n            }, function() {\n                _this.fireOnFinalChange();\n            });\n        };\n        _this.fireOnFinalChange = function() {\n            _this.setState({\n                isChanged: false\n            });\n            var _a = _this.props, onFinalChange = _a.onFinalChange, values = _a.values;\n            if (onFinalChange) {\n                onFinalChange(values);\n            }\n        };\n        _this.updateMarkRefs = function(props) {\n            if (!props.renderMark) {\n                _this.numOfMarks = undefined;\n                _this.markRefs = undefined;\n                return;\n            }\n            _this.numOfMarks = (props.max - props.min) / _this.props.step;\n            _this.markRefs = [];\n            for(var i = 0; i < _this.numOfMarks + 1; i++){\n                _this.markRefs[i] = React.createRef();\n            }\n        };\n        _this.calculateMarkOffsets = function() {\n            if (!_this.props.renderMark || !_this.trackRef || !_this.numOfMarks || !_this.markRefs || _this.trackRef.current === null) return;\n            var elStyles = window.getComputedStyle(_this.trackRef.current);\n            var trackWidth = parseInt(elStyles.width, 10);\n            var trackHeight = parseInt(elStyles.height, 10);\n            var paddingLeft = parseInt(elStyles.paddingLeft, 10);\n            var paddingTop = parseInt(elStyles.paddingTop, 10);\n            var res = [];\n            for(var i = 0; i < _this.numOfMarks + 1; i++){\n                var markHeight = 9999;\n                var markWidth = 9999;\n                if (_this.markRefs[i].current) {\n                    var markRect = _this.markRefs[i].current.getBoundingClientRect();\n                    markHeight = markRect.height;\n                    markWidth = markRect.width;\n                }\n                if (_this.props.direction === types_1.Direction.Left || _this.props.direction === types_1.Direction.Right) {\n                    res.push([\n                        Math.round(trackWidth / _this.numOfMarks * i + paddingLeft - markWidth / 2),\n                        -Math.round((markHeight - trackHeight) / 2)\n                    ]);\n                } else {\n                    res.push([\n                        Math.round(trackHeight / _this.numOfMarks * i + paddingTop - markHeight / 2),\n                        -Math.round((markWidth - trackWidth) / 2)\n                    ]);\n                }\n            }\n            _this.setState({\n                markOffsets: res\n            });\n        };\n        if (props.step === 0) {\n            throw new Error('\"step\" property should be a positive number');\n        }\n        _this.schdOnMouseMove = (0, utils_1.schd)(_this.onMouseMove);\n        _this.schdOnTouchMove = (0, utils_1.schd)(_this.onTouchMove);\n        _this.schdOnEnd = (0, utils_1.schd)(_this.onEnd);\n        _this.thumbRefs = props.values.map(function() {\n            return React.createRef();\n        });\n        _this.updateMarkRefs(props);\n        return _this;\n    }\n    Range.prototype.componentDidMount = function() {\n        var _this = this;\n        var _a = this.props, values = _a.values, min = _a.min, step = _a.step;\n        this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver(this.onResize) : {\n            observe: function() {\n                return window.addEventListener(\"resize\", _this.onResize);\n            },\n            unobserve: function() {\n                return window.removeEventListener(\"resize\", _this.onResize);\n            }\n        };\n        document.addEventListener(\"touchstart\", this.onMouseOrTouchStart, {\n            passive: false\n        });\n        document.addEventListener(\"mousedown\", this.onMouseOrTouchStart, {\n            passive: false\n        });\n        !this.props.allowOverlap && (0, utils_1.checkInitialOverlap)(this.props.values);\n        this.props.values.forEach(function(value) {\n            return (0, utils_1.checkBoundaries)(value, _this.props.min, _this.props.max);\n        });\n        this.resizeObserver.observe(this.trackRef.current);\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), this.props.rtl);\n        this.calculateMarkOffsets();\n        values.forEach(function(value) {\n            if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                console.warn(\"The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.\");\n            }\n        });\n    };\n    Range.prototype.componentDidUpdate = function(prevProps, prevState) {\n        var _a = this.props, max = _a.max, min = _a.min, step = _a.step, values = _a.values, rtl = _a.rtl;\n        if (prevProps.max !== max || prevProps.min !== min || prevProps.step !== step) {\n            this.updateMarkRefs(this.props);\n        }\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), rtl);\n        // ensure offsets are calculated when the refs for the marks have been created\n        // and those refs have been mounted to the dom\n        // on the state update in calculateOffsets with new markOffsets are calculated\n        if (prevProps.max !== max || prevProps.min !== min || prevProps.step !== step || prevState.markOffsets.length !== this.state.markOffsets.length) {\n            this.calculateMarkOffsets();\n            values.forEach(function(value) {\n                if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                    console.warn(\"The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.\");\n                }\n            });\n        }\n    };\n    Range.prototype.componentWillUnmount = function() {\n        var options = {\n            passive: false\n        };\n        document.removeEventListener(\"mousedown\", this.onMouseOrTouchStart, options);\n        // These need to be removed!!\n        document.removeEventListener(\"mousemove\", this.schdOnMouseMove);\n        document.removeEventListener(\"touchmove\", this.schdOnTouchMove);\n        document.removeEventListener(\"touchstart\", this.onMouseOrTouchStart);\n        document.removeEventListener(\"mouseup\", this.schdOnEnd);\n        document.removeEventListener(\"touchend\", this.schdOnEnd);\n        this.resizeObserver.unobserve(this.trackRef.current);\n    };\n    Range.prototype.render = function() {\n        var _this = this;\n        var _a = this.props, renderTrack = _a.renderTrack, renderThumb = _a.renderThumb, _b = _a.renderMark, renderMark = _b === void 0 ? function() {\n            return null;\n        } : _b, values = _a.values, min = _a.min, max = _a.max, allowOverlap = _a.allowOverlap, disabled = _a.disabled;\n        var _c = this.state, draggedThumbIndex = _c.draggedThumbIndex, thumbZIndexes = _c.thumbZIndexes, markOffsets = _c.markOffsets;\n        return renderTrack({\n            props: {\n                style: {\n                    // creates stacking context that prevents z-index applied to thumbs\n                    // interfere with other elements\n                    transform: \"scale(1)\",\n                    cursor: draggedThumbIndex > -1 ? \"grabbing\" : this.props.draggableTrack ? (0, utils_1.isVertical)(this.props.direction) ? \"ns-resize\" : \"ew-resize\" : values.length === 1 && !disabled ? \"pointer\" : \"inherit\"\n                },\n                onMouseDown: disabled ? utils_1.voidFn : this.onMouseDownTrack,\n                onTouchStart: disabled ? utils_1.voidFn : this.onTouchStartTrack,\n                ref: this.trackRef\n            },\n            isDragged: this.state.draggedThumbIndex > -1,\n            disabled: disabled,\n            children: __spreadArray(__spreadArray([], markOffsets.map(function(offset, index, arr) {\n                return renderMark({\n                    props: {\n                        style: _this.props.direction === types_1.Direction.Left || _this.props.direction === types_1.Direction.Right ? {\n                            position: \"absolute\",\n                            left: \"\".concat(offset[0], \"px\"),\n                            marginTop: \"\".concat(offset[1], \"px\")\n                        } : {\n                            position: \"absolute\",\n                            top: \"\".concat(offset[0], \"px\"),\n                            marginLeft: \"\".concat(offset[1], \"px\")\n                        },\n                        key: \"mark\".concat(index),\n                        ref: _this.markRefs[index]\n                    },\n                    index: index\n                });\n            }), true), values.map(function(value, index) {\n                var isDragged = _this.state.draggedThumbIndex === index;\n                return renderThumb({\n                    index: index,\n                    value: value,\n                    isDragged: isDragged,\n                    props: {\n                        style: {\n                            position: \"absolute\",\n                            zIndex: thumbZIndexes[index],\n                            cursor: disabled ? \"inherit\" : isDragged ? \"grabbing\" : \"grab\",\n                            userSelect: \"none\",\n                            touchAction: \"none\",\n                            WebkitUserSelect: \"none\",\n                            MozUserSelect: \"none\",\n                            msUserSelect: \"none\"\n                        },\n                        key: index,\n                        tabIndex: disabled ? undefined : 0,\n                        \"aria-valuemax\": allowOverlap ? max : values[index + 1] || max,\n                        \"aria-valuemin\": allowOverlap ? min : values[index - 1] || min,\n                        \"aria-valuenow\": value,\n                        draggable: false,\n                        ref: _this.thumbRefs[index],\n                        role: \"slider\",\n                        onKeyDown: disabled ? utils_1.voidFn : _this.onKeyDown,\n                        onKeyUp: disabled ? utils_1.voidFn : _this.onKeyUp\n                    }\n                });\n            }), true)\n        });\n    };\n    Range.defaultProps = {\n        step: 1,\n        direction: types_1.Direction.Right,\n        rtl: false,\n        disabled: false,\n        allowOverlap: false,\n        draggableTrack: false,\n        min: 0,\n        max: 100\n    };\n    return Range;\n}(React.Component);\nexports[\"default\"] = Range;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvUmFuZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsU0FBUyxJQUFLO0lBQ3hDLElBQUlDLGdCQUFnQixTQUFVQyxDQUFDLEVBQUVDLENBQUM7UUFDOUJGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztZQUFFQyxXQUFXLEVBQUU7UUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztZQUFJRCxFQUFFSSxTQUFTLEdBQUdIO1FBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1lBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlDLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7UUFBRTtRQUNwRyxPQUFPUCxjQUFjQyxHQUFHQztJQUM1QjtJQUNBLE9BQU8sU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQ2pCLElBQUksT0FBT0EsTUFBTSxjQUFjQSxNQUFNLE1BQ2pDLE1BQU0sSUFBSVMsVUFBVSx5QkFBeUJDLE9BQU9WLEtBQUs7UUFDN0RGLGNBQWNDLEdBQUdDO1FBQ2pCLFNBQVNXO1lBQU8sSUFBSSxDQUFDQyxXQUFXLEdBQUdiO1FBQUc7UUFDdENBLEVBQUVPLFNBQVMsR0FBR04sTUFBTSxPQUFPQyxPQUFPWSxNQUFNLENBQUNiLEtBQU1XLENBQUFBLEdBQUdMLFNBQVMsR0FBR04sRUFBRU0sU0FBUyxFQUFFLElBQUlLLElBQUc7SUFDdEY7QUFDSjtBQUNBLElBQUlHLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTWIsQ0FBQUEsT0FBT1ksTUFBTSxHQUFJLFNBQVNFLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7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LFFBQVEsRUFBRSxJQUFJVDt3QkFDM0QsaUJBQWlCaUcsZUFBZWxHLE1BQU1ULE1BQU0sQ0FBQ21CLFFBQVEsRUFBRSxJQUFJVjt3QkFDM0QsaUJBQWlCMUM7d0JBQ2pCME0sV0FBVzt3QkFDWGQsS0FBS25LLE1BQU1HLFNBQVMsQ0FBQ3dCLE1BQU07d0JBQzNCdUosTUFBTTt3QkFDTnBGLFdBQVdQLFdBQVc5RixRQUFRd0ssTUFBTSxHQUFHakssTUFBTThGLFNBQVM7d0JBQ3REUyxTQUFTaEIsV0FBVzlGLFFBQVF3SyxNQUFNLEdBQUdqSyxNQUFNdUcsT0FBTztvQkFDdEQ7Z0JBQ0o7WUFDSixJQUFJO1FBQ1I7SUFDSjtJQUNBMUcsTUFBTXNMLFlBQVksR0FBRztRQUNqQm5GLE1BQU07UUFDTmhGLFdBQVd0QixRQUFRd0MsU0FBUyxDQUFDQyxLQUFLO1FBQ2xDK0MsS0FBSztRQUNMSyxVQUFVO1FBQ1Y0QixjQUFjO1FBQ2Q1QyxnQkFBZ0I7UUFDaEJ0RCxLQUFLO1FBQ0xDLEtBQUs7SUFDVDtJQUNBLE9BQU9yQjtBQUNYLEVBQUVOLE1BQU02TCxTQUFTO0FBQ2pCOUwsa0JBQWUsR0FBR08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlL2xpYi9SYW5nZS5qcz8yMTYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBJTkNSRUFTRV9LRVlTID0gWydBcnJvd1JpZ2h0JywgJ0Fycm93VXAnLCAnaycsICdQYWdlVXAnXTtcbnZhciBERUNSRUFTRV9LRVlTID0gWydBcnJvd0xlZnQnLCAnQXJyb3dEb3duJywgJ2onLCAnUGFnZURvd24nXTtcbnZhciBSYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFuZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFuZ2UocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRyYWNrUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnRodW1iUmVmcyA9IFtdO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogWy0xLCAtMV0sXG4gICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogLTEsXG4gICAgICAgICAgICB0aHVtYlpJbmRleGVzOiBuZXcgQXJyYXkoX3RoaXMucHJvcHMudmFsdWVzLmxlbmd0aCkuZmlsbCgwKS5tYXAoZnVuY3Rpb24gKHQsIGkpIHsgcmV0dXJuIGk7IH0pLFxuICAgICAgICAgICAgaXNDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgICAgIG1hcmtPZmZzZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbiwgdmFsdWVzID0gX2EudmFsdWVzLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heDtcbiAgICAgICAgICAgIHZhciB0cmFja0VsZW1lbnQgPSBfdGhpcy50cmFja1JlZi5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIHRyYWNrUmVjdCA9IHRyYWNrRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB0cmFja1BhZGRpbmcgPSAoMCwgdXRpbHNfMS5nZXRQYWRkaW5nQW5kQm9yZGVyKSh0cmFja0VsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFRodW1icygpLm1hcChmdW5jdGlvbiAodGh1bWIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRodW1iT2Zmc2V0cyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgICAgIHZhciB0aHVtYlJlY3QgPSB0aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJNYXJnaW5zID0gKDAsIHV0aWxzXzEuZ2V0TWFyZ2luKSh0aHVtYik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID0gKHRodW1iTWFyZ2lucy5sZWZ0ICsgdHJhY2tQYWRkaW5nLmxlZnQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3QuaGVpZ2h0IC0gdHJhY2tSZWN0LmhlaWdodCkgLyAyICsgdHJhY2tQYWRkaW5nLnRvcCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoICogKDAsIHV0aWxzXzEucmVsYXRpdmVWYWx1ZSkodmFsdWVzW2luZGV4XSwgbWluLCBtYXgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVtYk9mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID0gKHRodW1iTWFyZ2lucy5yaWdodCArIHRyYWNrUGFkZGluZy5yaWdodCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRodW1iUmVjdC5oZWlnaHQgLSB0cmFja1JlY3QuaGVpZ2h0KSAvIDIgKyB0cmFja1BhZGRpbmcudG9wKSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3Qud2lkdGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3Qud2lkdGggKiAoMCwgdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKSh2YWx1ZXNbaW5kZXhdLCBtaW4sIG1heCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRodW1iT2Zmc2V0cztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRodW1iUmVjdC53aWR0aCAtIHRyYWNrUmVjdC53aWR0aCkgLyAyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJNYXJnaW5zLmxlZnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1BhZGRpbmcubGVmdCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ID0gLXRyYWNrUGFkZGluZy5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3QuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LmhlaWdodCAqICgwLCB1dGlsc18xLnJlbGF0aXZlVmFsdWUpKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRodW1iT2Zmc2V0cztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGh1bWJSZWN0LndpZHRoIC0gdHJhY2tSZWN0LndpZHRoKSAvIDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk1hcmdpbnMubGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUGFkZGluZy5sZWZ0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgPSAtdHJhY2tQYWRkaW5nLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC5oZWlnaHQgKiAoMCwgdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKSh2YWx1ZXNbaW5kZXhdLCBtaW4sIG1heCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVtYk9mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuYXNzZXJ0VW5yZWFjaGFibGUpKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFRodW1icyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy50cmFja1JlZiAmJiBfdGhpcy50cmFja1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oX3RoaXMudHJhY2tSZWYuY3VycmVudC5jaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKCdhcmlhLXZhbHVlbm93Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIHRodW1icyBmb3VuZCBpbiB0aGUgdHJhY2sgY29udGFpbmVyLiBEaWQgeW91IGZvcmdldCB0byBwYXNzICYgc3ByZWFkIHRoZSBgcHJvcHNgIHBhcmFtIGluIHJlbmRlclRyYWNrPycpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRUYXJnZXRJbmRleCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0VGh1bWJzKCkuZmluZEluZGV4KGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQgPT09IGUudGFyZ2V0IHx8IGNoaWxkLmNvbnRhaW5zKGUudGFyZ2V0KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFkZFRvdWNoRXZlbnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF90aGlzLnNjaGRPblRvdWNoTW92ZSwge1xuICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX3RoaXMuc2NoZE9uRW5kLCB7XG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfdGhpcy5zY2hkT25FbmQsIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFkZE1vdXNlRXZlbnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF90aGlzLnNjaGRPbk1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3VzZURvd25UcmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gIT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZS5wZXJzaXN0KCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpcy5hZGRNb3VzZUV2ZW50cyhlLm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy52YWx1ZXMubGVuZ3RoID4gMSAmJiBfdGhpcy5wcm9wcy5kcmFnZ2FibGVUcmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50aHVtYlJlZnMuc29tZShmdW5jdGlvbiAodGh1bWJSZWYpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGh1bWJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGUudGFyZ2V0KTsgfSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZHJhZ2dpbmcgdGhlIHdob2xlIHRyYWNrXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFtlLmNsaWVudFgsIGUuY2xpZW50WV1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbk1vdmUoZS5jbGllbnRYLCBlLmNsaWVudFkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIHRodW1iIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ2dlZFRodW1iSW5kZXggPSAoMCwgdXRpbHNfMS5nZXRDbG9zZXN0VGh1bWJJbmRleCkoX3RoaXMudGh1bWJSZWZzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5jdXJyZW50OyB9KSwgZS5jbGllbnRYLCBlLmNsaWVudFksIF90aGlzLnByb3BzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgdGh1bWIgd2hpY2ggaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy50aHVtYlJlZnNbZHJhZ2dlZFRodW1iSW5kZXhdLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGRyYWdnZWRUaHVtYkluZGV4XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEudHJhbnNsYXRlVGh1bWJzKShfdGhpcy5nZXRUaHVtYnMoKSwgX3RoaXMuZ2V0T2Zmc2V0cygpLCBfdGhpcy5wcm9wcy5ydGwpO1xuICAgICAgICAgICAgX3RoaXMuY2FsY3VsYXRlTWFya09mZnNldHMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Ub3VjaFN0YXJ0VHJhY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgZS5wZXJzaXN0KCk7XG4gICAgICAgICAgICBfdGhpcy5hZGRUb3VjaEV2ZW50cyhlLm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy52YWx1ZXMubGVuZ3RoID4gMSAmJiBfdGhpcy5wcm9wcy5kcmFnZ2FibGVUcmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50aHVtYlJlZnMuc29tZShmdW5jdGlvbiAodGh1bWJSZWYpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGh1bWJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGUudGFyZ2V0KTsgfSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZHJhZ2dpbmcgdGhlIHdob2xlIHRyYWNrXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFtlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFldXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgdGh1bWIgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgdHJhY2sgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIHZhciBkcmFnZ2VkVGh1bWJJbmRleCA9ICgwLCB1dGlsc18xLmdldENsb3Nlc3RUaHVtYkluZGV4KShfdGhpcy50aHVtYlJlZnMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmN1cnJlbnQ7IH0pLCBlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFksIF90aGlzLnByb3BzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgdGh1bWIgd2hpY2ggaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy50aHVtYlJlZnNbZHJhZ2dlZFRodW1iSW5kZXhdLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGRyYWdnZWRUaHVtYkluZGV4XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNUb3VjaCA9ICgwLCB1dGlsc18xLmlzVG91Y2hFdmVudCkoZSk7XG4gICAgICAgICAgICBpZiAoIWlzVG91Y2ggJiYgZS5idXR0b24gIT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuZ2V0VGFyZ2V0SW5kZXgoZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRNb3VzZUV2ZW50cyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdGh1bWJaSW5kZXhlczogX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlcy5tYXAoZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPD0gX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlc1tpbmRleF0gPyB0IDogdCAtIDE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpcy5vbk1vdmUoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpcy5vbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2UsIHN0ZXAgPSBfYS5zdGVwLCBydGwgPSBfYS5ydGwsIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIHZhciBpc0NoYW5nZWQgPSBfdGhpcy5zdGF0ZS5pc0NoYW5nZWQ7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5nZXRUYXJnZXRJbmRleChlLm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlciA9IHJ0bCB8fCBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQgfHwgZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duXG4gICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKElOQ1JFQVNFX0tFWVMuaW5jbHVkZXMoZS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc0NoYW5nZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZSgoMCwgdXRpbHNfMS5yZXBsYWNlQXQpKHZhbHVlcywgaW5kZXgsIF90aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlc1tpbmRleF0gKyBpbnZlcnRlciAqIChlLmtleSA9PT0gJ1BhZ2VVcCcgPyBzdGVwICogMTAgOiBzdGVwKSwgaW5kZXgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChERUNSRUFTRV9LRVlTLmluY2x1ZGVzKGUua2V5KSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNDaGFuZ2VkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UoKDAsIHV0aWxzXzEucmVwbGFjZUF0KSh2YWx1ZXMsIGluZGV4LCBfdGhpcy5ub3JtYWxpemVWYWx1ZSh2YWx1ZXNbaW5kZXhdIC1cbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ZXIgKiAoZS5rZXkgPT09ICdQYWdlRG93bicgPyBzdGVwICogMTAgOiBzdGVwKSwgaW5kZXgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleSA9PT0gJ1RhYicpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGRyYWdnZWRUaHVtYkluZGV4OiAtMSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGtleSBwcmVzc2VkIHdoZW4gdGh1bWIgd2FzIG1vdmluZywgZmlyZSBvbkZpbmFsQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uS2V5VXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IF90aGlzLnN0YXRlLmlzQ2hhbmdlZDtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogLTFcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uTW92ZSA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZSwgZHJhZ2dlZFRodW1iSW5kZXggPSBfYS5kcmFnZ2VkVGh1bWJJbmRleCwgZHJhZ2dlZFRyYWNrUG9zID0gX2EuZHJhZ2dlZFRyYWNrUG9zO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIGRpcmVjdGlvbiA9IF9iLmRpcmVjdGlvbiwgbWluID0gX2IubWluLCBtYXggPSBfYi5tYXgsIG9uQ2hhbmdlID0gX2Iub25DaGFuZ2UsIHZhbHVlcyA9IF9iLnZhbHVlcywgc3RlcCA9IF9iLnN0ZXAsIHJ0bCA9IF9iLnJ0bDtcbiAgICAgICAgICAgIGlmIChkcmFnZ2VkVGh1bWJJbmRleCA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3NbMF0gPT09IC0xICYmXG4gICAgICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zWzFdID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciB0cmFja0VsZW1lbnQgPSBfdGhpcy50cmFja1JlZi5jdXJyZW50O1xuICAgICAgICAgICAgLy8gSWYgY29tcG9uZW50IHdhcyBjbG9zZWQgZG93biBwcmVtYXR1cmVseSwgQSBsYXN0IG9uTW92ZSBjb3VsZCBiZSB0cmlnZ2VyZWQgYmFzZWQgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKClcbiAgICAgICAgICAgIGlmICghdHJhY2tFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHRyYWNrUmVjdCA9IHRyYWNrRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB0cmFja0xlbmd0aCA9ICgwLCB1dGlsc18xLmlzVmVydGljYWwpKGRpcmVjdGlvbilcbiAgICAgICAgICAgICAgICA/IHRyYWNrUmVjdC5oZWlnaHRcbiAgICAgICAgICAgICAgICA6IHRyYWNrUmVjdC53aWR0aDtcbiAgICAgICAgICAgIGlmIChkcmFnZ2VkVHJhY2tQb3NbMF0gIT09IC0xICYmIGRyYWdnZWRUcmFja1Bvc1sxXSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggaXQgbW92ZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlXG4gICAgICAgICAgICAgICAgdmFyIGRYID0gY2xpZW50WCAtIGRyYWdnZWRUcmFja1Bvc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZFkgPSBjbGllbnRZIC0gZHJhZ2dlZFRyYWNrUG9zWzFdO1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVsdGEgb2YgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSAoZFggLyB0cmFja0xlbmd0aCkgKiAobWF4IC0gbWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkRvd246XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uVXA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gKGRZIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLmFzc2VydFVucmVhY2hhYmxlKShkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnZlcnQgZm9yIFJUTFxuICAgICAgICAgICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFWYWx1ZSAqPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhVmFsdWUpID49IHN0ZXAgLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCBkZWx0YSBzbyBpdCBmaXRzIGludG8gdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMudGh1bWJSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlc1tpXSA9PT0gbWF4ICYmIE1hdGguc2lnbihkZWx0YVZhbHVlKSA9PT0gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsdWVzW2ldID09PSBtaW4gJiYgTWF0aC5zaWduKGRlbHRhVmFsdWUpID09PSAtMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRodW1iVmFsdWUgPSB2YWx1ZXNbaV0gKyBkZWx0YVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRodW1iVmFsdWUgPiBtYXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFWYWx1ZSA9IG1heCAtIHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRodW1iVmFsdWUgPCBtaW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFWYWx1ZSA9IG1pbiAtIHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGRlbHRhIHRvIGVhY2ggdGh1bWJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IHZhbHVlcy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy50aHVtYlJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlcyA9ICgwLCB1dGlsc18xLnJlcGxhY2VBdCkobmV3VmFsdWVzLCBpLCBfdGhpcy5ub3JtYWxpemVWYWx1ZSh2YWx1ZXNbaV0gKyBkZWx0YVZhbHVlLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zOiBbY2xpZW50WCwgY2xpZW50WV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2xpZW50WCAtIHRyYWNrUmVjdC5sZWZ0KSAvIHRyYWNrTGVuZ3RoKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRyYWNrTGVuZ3RoIC0gKGNsaWVudFggLSB0cmFja1JlY3QubGVmdCkpIC8gdHJhY2tMZW5ndGgpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1heCAtIG1pbikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY2xpZW50WSAtIHRyYWNrUmVjdC50b3ApIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRyYWNrTGVuZ3RoIC0gKGNsaWVudFkgLSB0cmFja1JlY3QudG9wKSkgLyB0cmFja0xlbmd0aCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF4IC0gbWluKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0VW5yZWFjaGFibGUpKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludmVydCBmb3IgUlRMXG4gICAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG1heCArIG1pbiAtIG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModmFsdWVzW2RyYWdnZWRUaHVtYkluZGV4XSAtIG5ld1ZhbHVlKSA+PSBzdGVwIC8gMikge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSgoMCwgdXRpbHNfMS5yZXBsYWNlQXQpKHZhbHVlcywgZHJhZ2dlZFRodW1iSW5kZXgsIF90aGlzLm5vcm1hbGl6ZVZhbHVlKG5ld1ZhbHVlLCBkcmFnZ2VkVGh1bWJJbmRleCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm5vcm1hbGl6ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBzdGVwID0gX2Euc3RlcCwgYWxsb3dPdmVybGFwID0gX2EuYWxsb3dPdmVybGFwLCB2YWx1ZXMgPSBfYS52YWx1ZXM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEubm9ybWFsaXplVmFsdWUpKHZhbHVlLCBpbmRleCwgbWluLCBtYXgsIHN0ZXAsIGFsbG93T3ZlcmxhcCwgdmFsdWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMuc2NoZE9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF90aGlzLnNjaGRPblRvdWNoTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX3RoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX3RoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5kcmFnZ2VkVGh1bWJJbmRleCA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5kcmFnZ2VkVHJhY2tQb3NbMF0gPT09IC0xICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUuZHJhZ2dlZFRyYWNrUG9zWzFdID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZHJhZ2dlZFRodW1iSW5kZXg6IC0xLCBkcmFnZ2VkVHJhY2tQb3M6IFstMSwgLTFdIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc0NoYW5nZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG9uRmluYWxDaGFuZ2UgPSBfYS5vbkZpbmFsQ2hhbmdlLCB2YWx1ZXMgPSBfYS52YWx1ZXM7XG4gICAgICAgICAgICBpZiAob25GaW5hbENoYW5nZSkge1xuICAgICAgICAgICAgICAgIG9uRmluYWxDaGFuZ2UodmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudXBkYXRlTWFya1JlZnMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMucmVuZGVyTWFyaykgeyAvLyBkb24ndCBjcmVhdGUgbWFyayByZWZzIHVubGVzcyB3ZSBhcmUgcmVuZGVyaW5nIG1hcmtzXG4gICAgICAgICAgICAgICAgX3RoaXMubnVtT2ZNYXJrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYXJrUmVmcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5udW1PZk1hcmtzID0gKHByb3BzLm1heCAtIHByb3BzLm1pbikgLyBfdGhpcy5wcm9wcy5zdGVwO1xuICAgICAgICAgICAgX3RoaXMubWFya1JlZnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubnVtT2ZNYXJrcyArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIF90aGlzLm1hcmtSZWZzW2ldID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5yZW5kZXJNYXJrIHx8XG4gICAgICAgICAgICAgICAgIV90aGlzLnRyYWNrUmVmIHx8XG4gICAgICAgICAgICAgICAgIV90aGlzLm51bU9mTWFya3MgfHxcbiAgICAgICAgICAgICAgICAhX3RoaXMubWFya1JlZnMgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFja1JlZi5jdXJyZW50ID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBlbFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKF90aGlzLnRyYWNrUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgdmFyIHRyYWNrV2lkdGggPSBwYXJzZUludChlbFN0eWxlcy53aWR0aCwgMTApO1xuICAgICAgICAgICAgdmFyIHRyYWNrSGVpZ2h0ID0gcGFyc2VJbnQoZWxTdHlsZXMuaGVpZ2h0LCAxMCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUludChlbFN0eWxlcy5wYWRkaW5nTGVmdCwgMTApO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdUb3AgPSBwYXJzZUludChlbFN0eWxlcy5wYWRkaW5nVG9wLCAxMCk7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLm51bU9mTWFya3MgKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya0hlaWdodCA9IDk5OTk7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtXaWR0aCA9IDk5OTk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm1hcmtSZWZzW2ldLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtSZWN0ID0gX3RoaXMubWFya1JlZnNbaV0uY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya0hlaWdodCA9IG1hcmtSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbWFya1dpZHRoID0gbWFya1JlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQgfHxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh0cmFja1dpZHRoIC8gX3RoaXMubnVtT2ZNYXJrcykgKiBpICsgcGFkZGluZ0xlZnQgLSBtYXJrV2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC1NYXRoLnJvdW5kKChtYXJrSGVpZ2h0IC0gdHJhY2tIZWlnaHQpIC8gMilcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh0cmFja0hlaWdodCAvIF90aGlzLm51bU9mTWFya3MpICogaSArIHBhZGRpbmdUb3AgLSBtYXJrSGVpZ2h0IC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAtTWF0aC5yb3VuZCgobWFya1dpZHRoIC0gdHJhY2tXaWR0aCkgLyAyKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IG1hcmtPZmZzZXRzOiByZXMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9wcy5zdGVwID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic3RlcFwiIHByb3BlcnR5IHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnNjaGRPbk1vdXNlTW92ZSA9ICgwLCB1dGlsc18xLnNjaGQpKF90aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgX3RoaXMuc2NoZE9uVG91Y2hNb3ZlID0gKDAsIHV0aWxzXzEuc2NoZCkoX3RoaXMub25Ub3VjaE1vdmUpO1xuICAgICAgICBfdGhpcy5zY2hkT25FbmQgPSAoMCwgdXRpbHNfMS5zY2hkKShfdGhpcy5vbkVuZCk7XG4gICAgICAgIF90aGlzLnRodW1iUmVmcyA9IHByb3BzLnZhbHVlcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVhY3QuY3JlYXRlUmVmKCk7IH0pO1xuICAgICAgICBfdGhpcy51cGRhdGVNYXJrUmVmcyhwcm9wcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIG1pbiA9IF9hLm1pbiwgc3RlcCA9IF9hLnN0ZXA7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSB3aW5kb3cuUmVzaXplT2JzZXJ2ZXJcbiAgICAgICAgICAgID8gbmV3IHdpbmRvdy5SZXNpemVPYnNlcnZlcih0aGlzLm9uUmVzaXplKVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIF90aGlzLm9uUmVzaXplKTsgfSxcbiAgICAgICAgICAgICAgICB1bm9ic2VydmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfdGhpcy5vblJlc2l6ZSk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uTW91c2VPclRvdWNoU3RhcnQsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VPclRvdWNoU3RhcnQsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAhdGhpcy5wcm9wcy5hbGxvd092ZXJsYXAgJiYgKDAsIHV0aWxzXzEuY2hlY2tJbml0aWFsT3ZlcmxhcCkodGhpcy5wcm9wcy52YWx1ZXMpO1xuICAgICAgICB0aGlzLnByb3BzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNoZWNrQm91bmRhcmllcykodmFsdWUsIF90aGlzLnByb3BzLm1pbiwgX3RoaXMucHJvcHMubWF4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnRyYWNrUmVmLmN1cnJlbnQpO1xuICAgICAgICAoMCwgdXRpbHNfMS50cmFuc2xhdGVUaHVtYnMpKHRoaXMuZ2V0VGh1bWJzKCksIHRoaXMuZ2V0T2Zmc2V0cygpLCB0aGlzLnByb3BzLnJ0bCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTWFya09mZnNldHMoKTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmlzU3RlcERpdmlzaWJsZSkobWluLCB2YWx1ZSwgc3RlcCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBgdmFsdWVzYCBwcm9wZXJ0eSBpcyBpbiBjb25mbGljdCB3aXRoIHRoZSBjdXJyZW50IGBzdGVwYCwgYG1pbmAsIGFuZCBgbWF4YCBwcm9wZXJ0aWVzLiBQbGVhc2UgcHJvdmlkZSB2YWx1ZXMgdGhhdCBhcmUgYWNjZXNzaWJsZSB1c2luZyB0aGUgbWluLCBtYXgsIGFuZCBzdGVwIHZhbHVlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIG1heCA9IF9hLm1heCwgbWluID0gX2EubWluLCBzdGVwID0gX2Euc3RlcCwgdmFsdWVzID0gX2EudmFsdWVzLCBydGwgPSBfYS5ydGw7XG4gICAgICAgIGlmIChwcmV2UHJvcHMubWF4ICE9PSBtYXggfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5taW4gIT09IG1pbiB8fFxuICAgICAgICAgICAgcHJldlByb3BzLnN0ZXAgIT09IHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFya1JlZnModGhpcy5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHV0aWxzXzEudHJhbnNsYXRlVGh1bWJzKSh0aGlzLmdldFRodW1icygpLCB0aGlzLmdldE9mZnNldHMoKSwgcnRsKTtcbiAgICAgICAgLy8gZW5zdXJlIG9mZnNldHMgYXJlIGNhbGN1bGF0ZWQgd2hlbiB0aGUgcmVmcyBmb3IgdGhlIG1hcmtzIGhhdmUgYmVlbiBjcmVhdGVkXG4gICAgICAgIC8vIGFuZCB0aG9zZSByZWZzIGhhdmUgYmVlbiBtb3VudGVkIHRvIHRoZSBkb21cbiAgICAgICAgLy8gb24gdGhlIHN0YXRlIHVwZGF0ZSBpbiBjYWxjdWxhdGVPZmZzZXRzIHdpdGggbmV3IG1hcmtPZmZzZXRzIGFyZSBjYWxjdWxhdGVkXG4gICAgICAgIGlmIChwcmV2UHJvcHMubWF4ICE9PSBtYXggfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5taW4gIT09IG1pbiB8fFxuICAgICAgICAgICAgcHJldlByb3BzLnN0ZXAgIT09IHN0ZXAgfHxcbiAgICAgICAgICAgIHByZXZTdGF0ZS5tYXJrT2Zmc2V0cy5sZW5ndGggIT09IHRoaXMuc3RhdGUubWFya09mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzKCk7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmlzU3RlcERpdmlzaWJsZSkobWluLCB2YWx1ZSwgc3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgYHZhbHVlc2AgcHJvcGVydHkgaXMgaW4gY29uZmxpY3Qgd2l0aCB0aGUgY3VycmVudCBgc3RlcGAsIGBtaW5gLCBhbmQgYG1heGAgcHJvcGVydGllcy4gUGxlYXNlIHByb3ZpZGUgdmFsdWVzIHRoYXQgYXJlIGFjY2Vzc2libGUgdXNpbmcgdGhlIG1pbiwgbWF4LCBhbmQgc3RlcCB2YWx1ZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VPclRvdWNoU3RhcnQsIG9wdGlvbnMpO1xuICAgICAgICAvLyBUaGVzZSBuZWVkIHRvIGJlIHJlbW92ZWQhIVxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLnNjaGRPbk1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuc2NoZE9uVG91Y2hNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZU9yVG91Y2hTdGFydCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLnRyYWNrUmVmLmN1cnJlbnQpO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgcmVuZGVyVHJhY2sgPSBfYS5yZW5kZXJUcmFjaywgcmVuZGVyVGh1bWIgPSBfYS5yZW5kZXJUaHVtYiwgX2IgPSBfYS5yZW5kZXJNYXJrLCByZW5kZXJNYXJrID0gX2IgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gOiBfYiwgdmFsdWVzID0gX2EudmFsdWVzLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heCwgYWxsb3dPdmVybGFwID0gX2EuYWxsb3dPdmVybGFwLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkO1xuICAgICAgICB2YXIgX2MgPSB0aGlzLnN0YXRlLCBkcmFnZ2VkVGh1bWJJbmRleCA9IF9jLmRyYWdnZWRUaHVtYkluZGV4LCB0aHVtYlpJbmRleGVzID0gX2MudGh1bWJaSW5kZXhlcywgbWFya09mZnNldHMgPSBfYy5tYXJrT2Zmc2V0cztcbiAgICAgICAgcmV0dXJuIHJlbmRlclRyYWNrKHtcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlcyBzdGFja2luZyBjb250ZXh0IHRoYXQgcHJldmVudHMgei1pbmRleCBhcHBsaWVkIHRvIHRodW1ic1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcmZlcmUgd2l0aCBvdGhlciBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKScsXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogZHJhZ2dlZFRodW1iSW5kZXggPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnZ3JhYmJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucHJvcHMuZHJhZ2dhYmxlVHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCB1dGlsc18xLmlzVmVydGljYWwpKHRoaXMucHJvcHMuZGlyZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICducy1yZXNpemUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2V3LXJlc2l6ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlcy5sZW5ndGggPT09IDEgJiYgIWRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2luaGVyaXQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbk1vdXNlRG93bjogZGlzYWJsZWQgPyB1dGlsc18xLnZvaWRGbiA6IHRoaXMub25Nb3VzZURvd25UcmFjayxcbiAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnQ6IGRpc2FibGVkID8gdXRpbHNfMS52b2lkRm4gOiB0aGlzLm9uVG91Y2hTdGFydFRyYWNrLFxuICAgICAgICAgICAgICAgIHJlZjogdGhpcy50cmFja1JlZlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRHJhZ2dlZDogdGhpcy5zdGF0ZS5kcmFnZ2VkVGh1bWJJbmRleCA+IC0xLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICAgICAgY2hpbGRyZW46IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgbWFya09mZnNldHMubWFwKGZ1bmN0aW9uIChvZmZzZXQsIGluZGV4LCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTWFyayh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogX3RoaXMucHJvcHMuZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCJcIi5jb25jYXQob2Zmc2V0WzBdLCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IFwiXCIuY29uY2F0KG9mZnNldFsxXSwgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCJcIi5jb25jYXQob2Zmc2V0WzBdLCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiBcIlwiLmNvbmNhdChvZmZzZXRbMV0sIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcIm1hcmtcIi5jb25jYXQoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfdGhpcy5tYXJrUmVmc1tpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgdHJ1ZSksIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0RyYWdnZWQgPSBfdGhpcy5zdGF0ZS5kcmFnZ2VkVGh1bWJJbmRleCA9PT0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlclRodW1iKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ2dlZDogaXNEcmFnZ2VkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IHRodW1iWkluZGV4ZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogZGlzYWJsZWQgPyAnaW5oZXJpdCcgOiBpc0RyYWdnZWQgPyAnZ3JhYmJpbmcnIDogJ2dyYWInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaEFjdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3pVc2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNVc2VyU2VsZWN0OiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IGRpc2FibGVkID8gdW5kZWZpbmVkIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbWF4JzogYWxsb3dPdmVybGFwID8gbWF4IDogdmFsdWVzW2luZGV4ICsgMV0gfHwgbWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiBhbGxvd092ZXJsYXAgPyBtaW4gOiB2YWx1ZXNbaW5kZXggLSAxXSB8fCBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW5vdyc6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogX3RoaXMudGh1bWJSZWZzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICdzbGlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogX3RoaXMub25LZXlEb3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlVcDogZGlzYWJsZWQgPyB1dGlsc18xLnZvaWRGbiA6IF90aGlzLm9uS2V5VXBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIHRydWUpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmFuZ2UuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBzdGVwOiAxLFxuICAgICAgICBkaXJlY3Rpb246IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0LFxuICAgICAgICBydGw6IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIGFsbG93T3ZlcmxhcDogZmFsc2UsXG4gICAgICAgIGRyYWdnYWJsZVRyYWNrOiBmYWxzZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEwMFxuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlO1xufShSZWFjdC5Db21wb25lbnQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJhbmdlO1xuIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fY3JlYXRlQmluZGluZyIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJwYWNrIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaSIsImwiLCJhciIsInNsaWNlIiwiY29uY2F0IiwiZXhwb3J0cyIsIlJlYWN0IiwicmVxdWlyZSIsInV0aWxzXzEiLCJ0eXBlc18xIiwiSU5DUkVBU0VfS0VZUyIsIkRFQ1JFQVNFX0tFWVMiLCJSYW5nZSIsIl9zdXBlciIsInByb3BzIiwiX3RoaXMiLCJ0cmFja1JlZiIsImNyZWF0ZVJlZiIsInRodW1iUmVmcyIsInN0YXRlIiwiZHJhZ2dlZFRyYWNrUG9zIiwiZHJhZ2dlZFRodW1iSW5kZXgiLCJ0aHVtYlpJbmRleGVzIiwidmFsdWVzIiwiZmlsbCIsIm1hcCIsInQiLCJpc0NoYW5nZWQiLCJtYXJrT2Zmc2V0cyIsImdldE9mZnNldHMiLCJfYSIsImRpcmVjdGlvbiIsIm1pbiIsIm1heCIsInRyYWNrRWxlbWVudCIsImN1cnJlbnQiLCJ0cmFja1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0cmFja1BhZGRpbmciLCJnZXRQYWRkaW5nQW5kQm9yZGVyIiwiZ2V0VGh1bWJzIiwidGh1bWIiLCJpbmRleCIsInRodW1iT2Zmc2V0cyIsIngiLCJ5IiwidGh1bWJSZWN0IiwidGh1bWJNYXJnaW5zIiwiZ2V0TWFyZ2luIiwiRGlyZWN0aW9uIiwiUmlnaHQiLCJsZWZ0IiwiaGVpZ2h0IiwidG9wIiwid2lkdGgiLCJyZWxhdGl2ZVZhbHVlIiwiTGVmdCIsInJpZ2h0IiwiVXAiLCJEb3duIiwiYXNzZXJ0VW5yZWFjaGFibGUiLCJjaGlsZHJlbiIsImZpbHRlciIsImVsIiwiaGFzQXR0cmlidXRlIiwiY29uc29sZSIsIndhcm4iLCJnZXRUYXJnZXRJbmRleCIsImUiLCJmaW5kSW5kZXgiLCJjaGlsZCIsInRhcmdldCIsImNvbnRhaW5zIiwiYWRkVG91Y2hFdmVudHMiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY2hkT25Ub3VjaE1vdmUiLCJwYXNzaXZlIiwic2NoZE9uRW5kIiwiYWRkTW91c2VFdmVudHMiLCJzY2hkT25Nb3VzZU1vdmUiLCJvbk1vdXNlRG93blRyYWNrIiwiYnV0dG9uIiwicGVyc2lzdCIsInByZXZlbnREZWZhdWx0IiwibmF0aXZlRXZlbnQiLCJkcmFnZ2FibGVUcmFjayIsInNvbWUiLCJ0aHVtYlJlZiIsInNldFN0YXRlIiwiY2xpZW50WCIsImNsaWVudFkiLCJvbk1vdmUiLCJnZXRDbG9zZXN0VGh1bWJJbmRleCIsImZvY3VzIiwib25SZXNpemUiLCJ0cmFuc2xhdGVUaHVtYnMiLCJydGwiLCJjYWxjdWxhdGVNYXJrT2Zmc2V0cyIsIm9uVG91Y2hTdGFydFRyYWNrIiwidG91Y2hlcyIsIm9uTW91c2VPclRvdWNoU3RhcnQiLCJkaXNhYmxlZCIsImlzVG91Y2giLCJpc1RvdWNoRXZlbnQiLCJNYXRoIiwiYXBwbHkiLCJvbk1vdXNlTW92ZSIsIm9uVG91Y2hNb3ZlIiwib25LZXlEb3duIiwib25DaGFuZ2UiLCJzdGVwIiwiaW52ZXJ0ZXIiLCJpbmNsdWRlcyIsImtleSIsInJlcGxhY2VBdCIsIm5vcm1hbGl6ZVZhbHVlIiwiZmlyZU9uRmluYWxDaGFuZ2UiLCJvbktleVVwIiwiX2IiLCJ0cmFja0xlbmd0aCIsImlzVmVydGljYWwiLCJkWCIsImRZIiwiZGVsdGFWYWx1ZSIsImFicyIsInNpZ24iLCJ0aHVtYlZhbHVlIiwibmV3VmFsdWVzIiwibmV3VmFsdWUiLCJhbGxvd092ZXJsYXAiLCJvbkVuZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbkZpbmFsQ2hhbmdlIiwidXBkYXRlTWFya1JlZnMiLCJyZW5kZXJNYXJrIiwibnVtT2ZNYXJrcyIsIm1hcmtSZWZzIiwiZWxTdHlsZXMiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhY2tXaWR0aCIsInBhcnNlSW50IiwidHJhY2tIZWlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJyZXMiLCJtYXJrSGVpZ2h0IiwibWFya1dpZHRoIiwibWFya1JlY3QiLCJwdXNoIiwicm91bmQiLCJFcnJvciIsInNjaGQiLCJjb21wb25lbnREaWRNb3VudCIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwiY2hlY2tJbml0aWFsT3ZlcmxhcCIsImZvckVhY2giLCJjaGVja0JvdW5kYXJpZXMiLCJpc1N0ZXBEaXZpc2libGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIm9wdGlvbnMiLCJyZW5kZXIiLCJyZW5kZXJUcmFjayIsInJlbmRlclRodW1iIiwiX2MiLCJzdHlsZSIsInRyYW5zZm9ybSIsImN1cnNvciIsIm9uTW91c2VEb3duIiwidm9pZEZuIiwib25Ub3VjaFN0YXJ0IiwicmVmIiwiaXNEcmFnZ2VkIiwib2Zmc2V0IiwiYXJyIiwicG9zaXRpb24iLCJtYXJnaW5Ub3AiLCJtYXJnaW5MZWZ0IiwiekluZGV4IiwidXNlclNlbGVjdCIsInRvdWNoQWN0aW9uIiwiV2Via2l0VXNlclNlbGVjdCIsIk1velVzZXJTZWxlY3QiLCJtc1VzZXJTZWxlY3QiLCJ0YWJJbmRleCIsImRyYWdnYWJsZSIsInJvbGUiLCJkZWZhdWx0UHJvcHMiLCJDb21wb25lbnQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-range/lib/Range.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-range/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.checkValuesAgainstBoundaries = exports.relativeValue = exports.useThumbOverlap = exports.Direction = exports.getTrackBackground = exports.Range = void 0;\nvar Range_1 = __importDefault(__webpack_require__(/*! ./Range */ \"(app-pages-browser)/./node_modules/react-range/lib/Range.js\"));\nexports.Range = Range_1.default;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/react-range/lib/utils.js\");\nObject.defineProperty(exports, \"getTrackBackground\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.getTrackBackground;\n    }\n}));\nObject.defineProperty(exports, \"useThumbOverlap\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.useThumbOverlap;\n    }\n}));\nObject.defineProperty(exports, \"relativeValue\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.relativeValue;\n    }\n}));\nObject.defineProperty(exports, \"checkValuesAgainstBoundaries\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.checkValuesAgainstBoundaries;\n    }\n}));\nvar types_1 = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/react-range/lib/types.js\");\nObject.defineProperty(exports, \"Direction\", ({\n    enumerable: true,\n    get: function() {\n        return types_1.Direction;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9DQUFvQyxHQUFHQSxxQkFBcUIsR0FBR0EsdUJBQXVCLEdBQUdBLGlCQUFpQixHQUFHQSwwQkFBMEIsR0FBR0EsYUFBYSxHQUFHLEtBQUs7QUFDL0osSUFBSVEsVUFBVWIsZ0JBQWdCYyxtQkFBT0EsQ0FBQyw0RUFBUztBQUMvQ1QsYUFBYSxHQUFHUSxRQUFRRSxPQUFPO0FBQy9CLElBQUlDLFVBQVVGLG1CQUFPQSxDQUFDLDRFQUFTO0FBQy9CWCxzREFBcUQ7SUFBRWMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUUwsa0JBQWtCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbklSLG1EQUFrRDtJQUFFYyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRUCxlQUFlO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0hOLGlEQUFnRDtJQUFFYyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRUixhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekhMLGdFQUErRDtJQUFFYyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRVCw0QkFBNEI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN2SixJQUFJWSxVQUFVTCxtQkFBT0EsQ0FBQyw0RUFBUztBQUMvQlgsNkNBQTRDO0lBQUVjLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFFBQVFULFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL2luZGV4LmpzP2MxOTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXMgPSBleHBvcnRzLnJlbGF0aXZlVmFsdWUgPSBleHBvcnRzLnVzZVRodW1iT3ZlcmxhcCA9IGV4cG9ydHMuRGlyZWN0aW9uID0gZXhwb3J0cy5nZXRUcmFja0JhY2tncm91bmQgPSBleHBvcnRzLlJhbmdlID0gdm9pZCAwO1xudmFyIFJhbmdlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmFuZ2VcIikpO1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlXzEuZGVmYXVsdDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRUcmFja0JhY2tncm91bmRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuZ2V0VHJhY2tCYWNrZ3JvdW5kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlVGh1bWJPdmVybGFwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnVzZVRodW1iT3ZlcmxhcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbGF0aXZlVmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucmVsYXRpdmVWYWx1ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllczsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXJlY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuRGlyZWN0aW9uOyB9IH0pO1xuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXMiLCJyZWxhdGl2ZVZhbHVlIiwidXNlVGh1bWJPdmVybGFwIiwiRGlyZWN0aW9uIiwiZ2V0VHJhY2tCYWNrZ3JvdW5kIiwiUmFuZ2UiLCJSYW5nZV8xIiwicmVxdWlyZSIsImRlZmF1bHQiLCJ1dGlsc18xIiwiZW51bWVyYWJsZSIsImdldCIsInR5cGVzXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-range/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-range/lib/types.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/types.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Direction = void 0;\nvar Direction;\n(function(Direction) {\n    Direction[\"Right\"] = \"to right\";\n    Direction[\"Left\"] = \"to left\";\n    Direction[\"Down\"] = \"to bottom\";\n    Direction[\"Up\"] = \"to top\";\n})(Direction = exports.Direction || (exports.Direction = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsSUFBSUU7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUMsUUFBUSxHQUFHO0lBQ3JCQSxTQUFTLENBQUMsT0FBTyxHQUFHO0lBQ3BCQSxTQUFTLENBQUMsT0FBTyxHQUFHO0lBQ3BCQSxTQUFTLENBQUMsS0FBSyxHQUFHO0FBQ3RCLEdBQUdBLFlBQVlGLFFBQVFFLFNBQVMsSUFBS0YsQ0FBQUEsaUJBQWlCLEdBQUcsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3R5cGVzLmpzP2I0MTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpcmVjdGlvbiA9IHZvaWQgMDtcbnZhciBEaXJlY3Rpb247XG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIERpcmVjdGlvbltcIlJpZ2h0XCJdID0gXCJ0byByaWdodFwiO1xuICAgIERpcmVjdGlvbltcIkxlZnRcIl0gPSBcInRvIGxlZnRcIjtcbiAgICBEaXJlY3Rpb25bXCJEb3duXCJdID0gXCJ0byBib3R0b21cIjtcbiAgICBEaXJlY3Rpb25bXCJVcFwiXSA9IFwidG8gdG9wXCI7XG59KShEaXJlY3Rpb24gPSBleHBvcnRzLkRpcmVjdGlvbiB8fCAoZXhwb3J0cy5EaXJlY3Rpb24gPSB7fSkpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRGlyZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-range/lib/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-range/lib/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/utils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __spreadArray = (void 0) && (void 0).__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/react-range/lib/types.js\");\nvar getStepDecimals = function(step) {\n    var decimals = step.toString().split(\".\")[1];\n    return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n    return event.touches && event.touches.length || event.changedTouches && event.changedTouches.length;\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    var precision = 8;\n    var roundedRes = Number(res.toFixed(precision));\n    return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value) return prev;\n        if (next && next < value) return next;\n    }\n    if (value > max) return max;\n    if (value < min) return min;\n    // `remainder` is a difference between the given value and a full step value\n    // that is closest lower to the given value and is in the range between the min value\n    // and the given value\n    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) % Math.floor(step * BIG_NUM);\n    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n    // Values with a remainder `< step/2` are rounded to the closest lower value\n    // while values with a remainder `= > step/2` are rounded to the closest bigger value\n    var res = Math.abs(remainder / BIG_NUM) < step / 2 ? rounded : rounded + step;\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\".concat(min, \") is equal/bigger than max (\").concat(max, \")\"));\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\".concat(value, \") is smaller than min (\").concat(min, \")\"));\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\".concat(value, \") is bigger than max (\").concat(max, \")\"));\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n    if (value < min) {\n        // set selectedValue to min\n        return min;\n    }\n    if (value > max) {\n        // set selectedValue to max\n        return max;\n    } else {\n        return value;\n    }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2) return;\n    if (!values.slice(1).every(function(item, i) {\n        return values[i] <= item;\n    })) {\n        throw new RangeError(\"values={[\".concat(values, \"]} needs to be sorted when allowOverlap={false}\"));\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"margin-top\"], 10),\n        bottom: parseInt(style[\"margin-bottom\"], 10),\n        left: parseInt(style[\"margin-left\"], 10),\n        right: parseInt(style[\"margin-right\"], 10)\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"padding-top\"], 10) + parseInt(style[\"border-top-width\"], 10),\n        bottom: parseInt(style[\"padding-bottom\"], 10) + parseInt(style[\"border-bottom-width\"], 10),\n        left: parseInt(style[\"padding-left\"], 10) + parseInt(style[\"border-left-width\"], 10),\n        right: parseInt(style[\"padding-right\"], 10) + parseInt(style[\"border-right-width\"], 10)\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function(element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */ function getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n    var thumbIndex = 0;\n    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n    for(var i = 1; i < thumbs.length; i++){\n        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n        if (thumbDistance < minThumbDistance) {\n            minThumbDistance = thumbDistance;\n            thumbIndex = i;\n        }\n    }\n    return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function(fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function() {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    } else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    // sort values ascending\n    var progress = values.slice(0).sort(function(a, b) {\n        return a - b;\n    }).map(function(value) {\n        return (value - min) / (max - min) * 100;\n    });\n    var middle = progress.reduce(function(acc, point, index) {\n        return \"\".concat(acc, \", \").concat(colors[index], \" \").concat(point, \"%, \").concat(colors[index + 1], \" \").concat(point, \"%\");\n    }, \"\");\n    return \"linear-gradient(\".concat(direction, \", \").concat(colors[0], \" 0%\").concat(middle, \", \").concat(colors[colors.length - 1], \" 100%)\");\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() {}\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */ var getThumbWidth = function(thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) {\n        valueToLabel = function(value) {\n            return value;\n        };\n    }\n    var width = Math.ceil(__spreadArray([\n        thumbEl\n    ], Array.from(thumbEl.children), true).reduce(function(width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */ if (el.innerText && el.innerText.includes(separator) && el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = \"hidden\";\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */ var getOverlaps = function(index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) {\n        valueToLabel = function(value) {\n            return value;\n        };\n    }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */ var buildOverlaps = function(thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */ offsets.forEach(function(_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex && (thumbX >= siblingX && thumbX <= siblingX + siblingWidth || thumbX + thumbXWidth >= siblingX && thumbX + thumbXWidth <= siblingX + siblingWidth)) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArray(__spreadArray([], overlaps, true), [\n                        thumbIndex,\n                        siblingIndex\n                    ], false);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */ var useThumbOverlap = function(rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) {\n        step = 0.1;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (valueToLabel === void 0) {\n        valueToLabel = function(value) {\n            return value;\n        };\n    }\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = (0, react_1.useState)({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = (0, react_1.useState)(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    (0, react_1.useEffect)(function() {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1) return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */ var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */ if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */ var offsetsX = overlaps.reduce(function(a, c, i, s) {\n                    return a.length ? __spreadArray(__spreadArray([], a, true), [\n                        offsets_1[s[i]].x\n                    ], false) : [\n                        offsets_1[s[i]].x\n                    ];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */ if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */ var labelValues_1 = [];\n                    overlaps.forEach(function(thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */ labelValue_1 = Array.from(new Set(labelValues_1.sort(function(a, b) {\n                        return parseFloat(a) - parseFloat(b);\n                    }))).map(valueToLabel).join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */ var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;\n                    newStyle.left = \"\".concat(Math.abs(first - (last + lastWidth)) / 2, \"px\");\n                    newStyle.transform = \"translate(-50%, 0)\";\n                } else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = \"hidden\";\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [\n        rangeRef,\n        values\n    ]);\n    return [\n        labelValue,\n        labelStyle\n    ];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */ function getThumbDistance(thumbEl, clientX, clientY, direction) {\n    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n    return isVertical(direction) ? Math.abs(clientY - (top + height / 2)) : Math.abs(clientX - (left + width / 2));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxnQkFBZ0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxhQUFhLElBQUssU0FBVUMsRUFBRSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDeEUsSUFBSUEsUUFBUUMsVUFBVUMsTUFBTSxLQUFLLEdBQUcsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLElBQUlMLEtBQUtHLE1BQU0sRUFBRUcsSUFBSUYsSUFBSUMsR0FBR0QsSUFBSztRQUNqRixJQUFJRSxNQUFNLENBQUVGLENBQUFBLEtBQUtKLElBQUcsR0FBSTtZQUNwQixJQUFJLENBQUNNLElBQUlBLEtBQUtDLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNWLE1BQU0sR0FBR0k7WUFDbERFLEVBQUUsQ0FBQ0YsRUFBRSxHQUFHSixJQUFJLENBQUNJLEVBQUU7UUFDbkI7SUFDSjtJQUNBLE9BQU9MLEdBQUdZLE1BQU0sQ0FBQ0wsTUFBTUMsTUFBTUMsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ1Y7QUFDdEQ7QUFDQVksOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSx5QkFBeUIsR0FBR0EsY0FBYyxHQUFHQSwwQkFBMEIsR0FBR0EsaUJBQWlCLEdBQUdBLFlBQVksR0FBR0EsaUJBQWlCLEdBQUdBLDRCQUE0QixHQUFHQSx1QkFBdUIsR0FBR0EsMkJBQTJCLEdBQUdBLGlCQUFpQixHQUFHQSwyQkFBMkIsR0FBR0Esb0NBQW9DLEdBQUdBLHVCQUF1QixHQUFHQSxrQkFBa0IsR0FBR0EscUJBQXFCLEdBQUdBLHNCQUFzQixHQUFHQSx1QkFBdUIsR0FBR0Esb0JBQW9CLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDM2YsSUFBSXNCLFVBQVVDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzdCLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDLDRFQUFTO0FBQy9CLElBQUlGLGtCQUFrQixTQUFVSSxJQUFJO0lBQ2hDLElBQUlDLFdBQVdELEtBQUtFLFFBQVEsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQzVDLE9BQU9GLFdBQVdBLFNBQVNyQyxNQUFNLEdBQUc7QUFDeEM7QUFDQVcsdUJBQXVCLEdBQUdxQjtBQUMxQixTQUFTRCxhQUFhUyxLQUFLO0lBQ3ZCLE9BQVEsTUFBT0MsT0FBTyxJQUFJRCxNQUFNQyxPQUFPLENBQUN6QyxNQUFNLElBQ3pDd0MsTUFBTUUsY0FBYyxJQUFJRixNQUFNRSxjQUFjLENBQUMxQyxNQUFNO0FBQzVEO0FBQ0FXLG9CQUFvQixHQUFHb0I7QUFDdkIsU0FBU0QsZ0JBQWdCYSxHQUFHLEVBQUVDLEdBQUcsRUFBRVIsSUFBSTtJQUNuQyxJQUFJUyxNQUFNLENBQUNELE1BQU1ELEdBQUUsSUFBS1A7SUFDeEIsSUFBSVUsWUFBWTtJQUNoQixJQUFJQyxhQUFhQyxPQUFPSCxJQUFJSSxPQUFPLENBQUNIO0lBQ3BDLE9BQU9JLFNBQVNILFdBQVdULFFBQVEsSUFBSSxRQUFRUztBQUNuRDtBQUNBcEMsdUJBQXVCLEdBQUdtQjtBQUMxQixTQUFTRCxlQUFlakIsS0FBSyxFQUFFdUMsS0FBSyxFQUFFUixHQUFHLEVBQUVDLEdBQUcsRUFBRVIsSUFBSSxFQUFFZ0IsWUFBWSxFQUFFQyxNQUFNO0lBQ3RFLElBQUlDLFVBQVU7SUFDZDFDLFFBQVEyQyxLQUFLQyxLQUFLLENBQUM1QyxRQUFRMEMsV0FBV0E7SUFDdEMsSUFBSSxDQUFDRixjQUFjO1FBQ2YsSUFBSUssT0FBT0osTUFBTSxDQUFDRixRQUFRLEVBQUU7UUFDNUIsSUFBSU8sT0FBT0wsTUFBTSxDQUFDRixRQUFRLEVBQUU7UUFDNUIsSUFBSU0sUUFBUUEsT0FBTzdDLE9BQ2YsT0FBTzZDO1FBQ1gsSUFBSUMsUUFBUUEsT0FBTzlDLE9BQ2YsT0FBTzhDO0lBQ2Y7SUFDQSxJQUFJOUMsUUFBUWdDLEtBQ1IsT0FBT0E7SUFDWCxJQUFJaEMsUUFBUStCLEtBQ1IsT0FBT0E7SUFDWCw0RUFBNEU7SUFDNUUscUZBQXFGO0lBQ3JGLHNCQUFzQjtJQUN0QixJQUFJZ0IsWUFBWUosS0FBS0ssS0FBSyxDQUFDaEQsUUFBUTBDLFVBQVVYLE1BQU1XLFdBQy9DQyxLQUFLSyxLQUFLLENBQUN4QixPQUFPa0I7SUFDdEIsSUFBSU8sa0JBQWtCTixLQUFLSyxLQUFLLENBQUNoRCxRQUFRMEMsVUFBVUMsS0FBS08sR0FBRyxDQUFDSDtJQUM1RCxJQUFJSSxVQUFVSixjQUFjLElBQUkvQyxRQUFRaUQsa0JBQWtCUDtJQUMxRCw0RUFBNEU7SUFDNUUscUZBQXFGO0lBQ3JGLElBQUlULE1BQU1VLEtBQUtPLEdBQUcsQ0FBQ0gsWUFBWUwsV0FBV2xCLE9BQU8sSUFDM0MyQixVQUNBQSxVQUFVM0I7SUFDaEIsSUFBSTRCLGdCQUFnQixDQUFDLEdBQUdyRCxRQUFRcUIsZUFBZSxFQUFFSTtJQUNqRCxPQUFPNkIsV0FBV3BCLElBQUlJLE9BQU8sQ0FBQ2U7QUFDbEM7QUFDQXJELHNCQUFzQixHQUFHa0I7QUFDekIsU0FBU0QsY0FBY2hCLEtBQUssRUFBRStCLEdBQUcsRUFBRUMsR0FBRztJQUNsQyxPQUFPLENBQUNoQyxRQUFRK0IsR0FBRSxJQUFNQyxDQUFBQSxNQUFNRCxHQUFFO0FBQ3BDO0FBQ0FoQyxxQkFBcUIsR0FBR2lCO0FBQ3hCLFNBQVNELFdBQVd1QyxTQUFTO0lBQ3pCLE9BQU9BLGNBQWMvQixRQUFRZ0MsU0FBUyxDQUFDQyxFQUFFLElBQUlGLGNBQWMvQixRQUFRZ0MsU0FBUyxDQUFDRSxJQUFJO0FBQ3JGO0FBQ0ExRCxrQkFBa0IsR0FBR2dCO0FBQ3JCLFNBQVNELGdCQUFnQmQsS0FBSyxFQUFFK0IsR0FBRyxFQUFFQyxHQUFHO0lBQ3BDLElBQUlELE9BQU9DLEtBQUs7UUFDWixNQUFNLElBQUkwQixXQUFXLFFBQVE5RCxNQUFNLENBQUNtQyxLQUFLLGdDQUFnQ25DLE1BQU0sQ0FBQ29DLEtBQUs7SUFDekY7SUFDQSxJQUFJaEMsUUFBUStCLEtBQUs7UUFDYixNQUFNLElBQUkyQixXQUFXLFVBQVU5RCxNQUFNLENBQUNJLE9BQU8sMkJBQTJCSixNQUFNLENBQUNtQyxLQUFLO0lBQ3hGO0lBQ0EsSUFBSS9CLFFBQVFnQyxLQUFLO1FBQ2IsTUFBTSxJQUFJMEIsV0FBVyxVQUFVOUQsTUFBTSxDQUFDSSxPQUFPLDBCQUEwQkosTUFBTSxDQUFDb0MsS0FBSztJQUN2RjtBQUNKO0FBQ0FqQyx1QkFBdUIsR0FBR2U7QUFDMUIsU0FBU0QsNkJBQTZCYixLQUFLLEVBQUUrQixHQUFHLEVBQUVDLEdBQUc7SUFDakQsSUFBSWhDLFFBQVErQixLQUFLO1FBQ2IsMkJBQTJCO1FBQzNCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJL0IsUUFBUWdDLEtBQUs7UUFDYiwyQkFBMkI7UUFDM0IsT0FBT0E7SUFDWCxPQUNLO1FBQ0QsT0FBT2hDO0lBQ1g7QUFDSjtBQUNBRCxvQ0FBb0MsR0FBR2M7QUFDdkMsU0FBU0Qsb0JBQW9CNkIsTUFBTTtJQUMvQixJQUFJQSxPQUFPckQsTUFBTSxHQUFHLEdBQ2hCO0lBQ0osSUFBSSxDQUFDcUQsT0FBTy9DLEtBQUssQ0FBQyxHQUFHaUUsS0FBSyxDQUFDLFNBQVVDLElBQUksRUFBRXZFLENBQUM7UUFBSSxPQUFPb0QsTUFBTSxDQUFDcEQsRUFBRSxJQUFJdUU7SUFBTSxJQUFJO1FBQzFFLE1BQU0sSUFBSUYsV0FBVyxZQUFZOUQsTUFBTSxDQUFDNkMsUUFBUTtJQUNwRDtBQUNKO0FBQ0ExQywyQkFBMkIsR0FBR2E7QUFDOUIsU0FBU0QsVUFBVWtELE9BQU87SUFDdEIsSUFBSUMsUUFBUUMsT0FBT0MsZ0JBQWdCLENBQUNIO0lBQ3BDLE9BQU87UUFDSEksS0FBSzNCLFNBQVN3QixLQUFLLENBQUMsYUFBYSxFQUFFO1FBQ25DSSxRQUFRNUIsU0FBU3dCLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRTtRQUN6Q0ssTUFBTTdCLFNBQVN3QixLQUFLLENBQUMsY0FBYyxFQUFFO1FBQ3JDTSxPQUFPOUIsU0FBU3dCLEtBQUssQ0FBQyxlQUFlLEVBQUU7SUFDM0M7QUFDSjtBQUNBL0QsaUJBQWlCLEdBQUdZO0FBQ3BCLFNBQVNELG9CQUFvQm1ELE9BQU87SUFDaEMsSUFBSUMsUUFBUUMsT0FBT0MsZ0JBQWdCLENBQUNIO0lBQ3BDLE9BQU87UUFDSEksS0FBSzNCLFNBQVN3QixLQUFLLENBQUMsY0FBYyxFQUFFLE1BQU14QixTQUFTd0IsS0FBSyxDQUFDLG1CQUFtQixFQUFFO1FBQzlFSSxRQUFRNUIsU0FBU3dCLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxNQUFNeEIsU0FBU3dCLEtBQUssQ0FBQyxzQkFBc0IsRUFBRTtRQUN2RkssTUFBTTdCLFNBQVN3QixLQUFLLENBQUMsZUFBZSxFQUFFLE1BQU14QixTQUFTd0IsS0FBSyxDQUFDLG9CQUFvQixFQUFFO1FBQ2pGTSxPQUFPOUIsU0FBU3dCLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNeEIsU0FBU3dCLEtBQUssQ0FBQyxxQkFBcUIsRUFBRTtJQUN4RjtBQUNKO0FBQ0EvRCwyQkFBMkIsR0FBR1c7QUFDOUIsU0FBU0QsZ0JBQWdCNEQsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDM0MsSUFBSUMsV0FBV0QsTUFBTSxDQUFDLElBQUk7SUFDMUJGLFNBQVNJLE9BQU8sQ0FBQyxTQUFVWixPQUFPLEVBQUV0QixLQUFLO1FBQ3JDLE9BQU9oQyxVQUFVc0QsU0FBU1csV0FBV0YsT0FBTyxDQUFDL0IsTUFBTSxDQUFDbUMsQ0FBQyxFQUFFSixPQUFPLENBQUMvQixNQUFNLENBQUNvQyxDQUFDO0lBQzNFO0FBQ0o7QUFDQTVFLHVCQUF1QixHQUFHVTtBQUMxQjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxxQkFBcUJvRSxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFeEIsU0FBUztJQUM3RCxJQUFJeUIsYUFBYTtJQUNqQixJQUFJQyxtQkFBbUJDLGlCQUFpQkwsTUFBTSxDQUFDLEVBQUUsRUFBRUMsU0FBU0MsU0FBU3hCO0lBQ3JFLElBQUssSUFBSWpFLElBQUksR0FBR0EsSUFBSXVGLE9BQU94RixNQUFNLEVBQUVDLElBQUs7UUFDcEMsSUFBSTZGLGdCQUFnQkQsaUJBQWlCTCxNQUFNLENBQUN2RixFQUFFLEVBQUV3RixTQUFTQyxTQUFTeEI7UUFDbEUsSUFBSTRCLGdCQUFnQkYsa0JBQWtCO1lBQ2xDQSxtQkFBbUJFO1lBQ25CSCxhQUFhMUY7UUFDakI7SUFDSjtJQUNBLE9BQU8wRjtBQUNYO0FBQ0FoRiw0QkFBNEIsR0FBR1M7QUFDL0IsU0FBU0QsVUFBVXNELE9BQU8sRUFBRWEsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCZCxRQUFRQyxLQUFLLENBQUNxQixTQUFTLEdBQUcsYUFBYXZGLE1BQU0sQ0FBQzhFLEdBQUcsUUFBUTlFLE1BQU0sQ0FBQytFLEdBQUc7QUFDdkU7QUFDQTVFLGlCQUFpQixHQUFHUTtBQUNwQix1REFBdUQ7QUFDdkQsSUFBSUQsT0FBTyxTQUFVOEUsRUFBRTtJQUNuQixJQUFJQyxXQUFXLEVBQUU7SUFDakIsSUFBSUMsVUFBVTtJQUNkLElBQUlDLFlBQVk7UUFDWixJQUFJQyxPQUFPLEVBQUU7UUFDYixJQUFLLElBQUlDLEtBQUssR0FBR0EsS0FBS3RHLFVBQVVDLE1BQU0sRUFBRXFHLEtBQU07WUFDMUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHdEcsU0FBUyxDQUFDc0csR0FBRztRQUM1QjtRQUNBSixXQUFXRztRQUNYLElBQUlGLFNBQVM7WUFDVDtRQUNKO1FBQ0FBLFVBQVVJLHNCQUFzQjtZQUM1QkosVUFBVTtZQUNWRixHQUFHTyxLQUFLLENBQUMsS0FBSyxHQUFHTjtRQUNyQjtJQUNKO0lBQ0EsT0FBT0U7QUFDWDtBQUNBeEYsWUFBWSxHQUFHTztBQUNmLFNBQVNELFVBQVVvQyxNQUFNLEVBQUVGLEtBQUssRUFBRXZDLEtBQUs7SUFDbkMsSUFBSTRGLE1BQU1uRCxPQUFPL0MsS0FBSyxDQUFDO0lBQ3ZCa0csR0FBRyxDQUFDckQsTUFBTSxHQUFHdkM7SUFDYixPQUFPNEY7QUFDWDtBQUNBN0YsaUJBQWlCLEdBQUdNO0FBQ3BCLFNBQVNELG1CQUFtQnlGLEVBQUU7SUFDMUIsSUFBSXBELFNBQVNvRCxHQUFHcEQsTUFBTSxFQUFFcUQsU0FBU0QsR0FBR0MsTUFBTSxFQUFFL0QsTUFBTThELEdBQUc5RCxHQUFHLEVBQUVDLE1BQU02RCxHQUFHN0QsR0FBRyxFQUFFK0QsS0FBS0YsR0FBR3ZDLFNBQVMsRUFBRUEsWUFBWXlDLE9BQU8sS0FBSyxJQUFJeEUsUUFBUWdDLFNBQVMsQ0FBQ3lDLEtBQUssR0FBR0QsSUFBSUUsS0FBS0osR0FBR3RCLEdBQUcsRUFBRUEsTUFBTTBCLE9BQU8sS0FBSyxJQUFJLFFBQVFBO0lBQ2hNLElBQUkxQixPQUFPakIsY0FBYy9CLFFBQVFnQyxTQUFTLENBQUN5QyxLQUFLLEVBQUU7UUFDOUMxQyxZQUFZL0IsUUFBUWdDLFNBQVMsQ0FBQzJDLElBQUk7SUFDdEMsT0FDSyxJQUFJM0IsT0FBT2hELFFBQVFnQyxTQUFTLENBQUMyQyxJQUFJLEVBQUU7UUFDcEM1QyxZQUFZL0IsUUFBUWdDLFNBQVMsQ0FBQ3lDLEtBQUs7SUFDdkM7SUFDQSx3QkFBd0I7SUFDeEIsSUFBSUcsV0FBVzFELE9BQU8vQyxLQUFLLENBQUMsR0FBRzBHLElBQUksQ0FBQyxTQUFVQyxDQUFDLEVBQUVDLENBQUM7UUFBSSxPQUFPRCxJQUFJQztJQUFHLEdBQUdDLEdBQUcsQ0FBQyxTQUFVdkcsS0FBSztRQUFJLE9BQU8sQ0FBRUEsUUFBUStCLEdBQUUsSUFBTUMsQ0FBQUEsTUFBTUQsR0FBRSxJQUFNO0lBQUs7SUFDMUksSUFBSXlFLFNBQVNMLFNBQVNNLE1BQU0sQ0FBQyxTQUFVQyxHQUFHLEVBQUVDLEtBQUssRUFBRXBFLEtBQUs7UUFDcEQsT0FBTyxHQUFHM0MsTUFBTSxDQUFDOEcsS0FBSyxNQUFNOUcsTUFBTSxDQUFDa0csTUFBTSxDQUFDdkQsTUFBTSxFQUFFLEtBQUszQyxNQUFNLENBQUMrRyxPQUFPLE9BQU8vRyxNQUFNLENBQUNrRyxNQUFNLENBQUN2RCxRQUFRLEVBQUUsRUFBRSxLQUFLM0MsTUFBTSxDQUFDK0csT0FBTztJQUM3SCxHQUFHO0lBQ0gsT0FBTyxtQkFBbUIvRyxNQUFNLENBQUMwRCxXQUFXLE1BQU0xRCxNQUFNLENBQUNrRyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU9sRyxNQUFNLENBQUM0RyxRQUFRLE1BQU01RyxNQUFNLENBQUNrRyxNQUFNLENBQUNBLE9BQU8xRyxNQUFNLEdBQUcsRUFBRSxFQUFFO0FBQ3RJO0FBQ0FXLDBCQUEwQixHQUFHSztBQUM3QixTQUFTRCxVQUFXO0FBQ3BCSixjQUFjLEdBQUdJO0FBQ2pCLFNBQVNELGtCQUFrQndFLENBQUM7SUFDeEIsTUFBTSxJQUFJa0MsTUFBTTtBQUNwQjtBQUNBN0cseUJBQXlCLEdBQUdHO0FBQzVCOzs7Ozs7Q0FNQyxHQUNELElBQUkyRyxnQkFBZ0IsU0FBVUMsT0FBTyxFQUFFOUcsS0FBSyxFQUFFK0csU0FBUyxFQUFFM0QsYUFBYSxFQUFFNEQsWUFBWTtJQUNoRixJQUFJQSxpQkFBaUIsS0FBSyxHQUFHO1FBQUVBLGVBQWUsU0FBVWhILEtBQUs7WUFBSSxPQUFPQTtRQUFPO0lBQUc7SUFDbEYsSUFBSWlILFFBQVF0RSxLQUFLdUUsSUFBSSxDQUFDbkksY0FBYztRQUFDK0g7S0FBUSxFQUFFdEgsTUFBTVAsSUFBSSxDQUFDNkgsUUFBUUssUUFBUSxHQUFHLE1BQU1WLE1BQU0sQ0FBQyxTQUFVUSxLQUFLLEVBQUVHLEVBQUU7UUFDekcsSUFBSUMsVUFBVTFFLEtBQUt1RSxJQUFJLENBQUNFLEdBQUdFLHFCQUFxQixHQUFHTCxLQUFLO1FBQ3hEOzs7O1NBSUMsR0FDRCxJQUFJRyxHQUFHRyxTQUFTLElBQ1pILEdBQUdHLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDVCxjQUN0QkssR0FBR0ssaUJBQWlCLEtBQUssR0FBRztZQUM1QixJQUFJQyxVQUFVTixHQUFHTyxTQUFTLENBQUM7WUFDM0JELFFBQVFFLFNBQVMsR0FBR1osYUFBYWhILE1BQU1xQyxPQUFPLENBQUNlO1lBQy9Dc0UsUUFBUTVELEtBQUssQ0FBQytELFVBQVUsR0FBRztZQUMzQkMsU0FBU0MsSUFBSSxDQUFDQyxXQUFXLENBQUNOO1lBQzFCTCxVQUFVMUUsS0FBS3VFLElBQUksQ0FBQ1EsUUFBUUoscUJBQXFCLEdBQUdMLEtBQUs7WUFDekRhLFNBQVNDLElBQUksQ0FBQ0UsV0FBVyxDQUFDUDtRQUM5QjtRQUNBLE9BQU9MLFVBQVVKLFFBQVFJLFVBQVVKO0lBQ3ZDLEdBQUdILFFBQVFRLHFCQUFxQixHQUFHTCxLQUFLO0lBQ3hDLE9BQU9BO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELElBQUlpQixjQUFjLFNBQVUzRixLQUFLLEVBQUUrQixPQUFPLEVBQUVNLE1BQU0sRUFBRW5DLE1BQU0sRUFBRXNFLFNBQVMsRUFBRTNELGFBQWEsRUFBRTRELFlBQVk7SUFDOUYsSUFBSUEsaUJBQWlCLEtBQUssR0FBRztRQUFFQSxlQUFlLFNBQVVoSCxLQUFLO1lBQUksT0FBT0E7UUFBTztJQUFHO0lBQ2xGLElBQUltSSxXQUFXLEVBQUU7SUFDakI7Ozs7S0FJQyxHQUNELElBQUlDLGdCQUFnQixTQUFVckQsVUFBVTtRQUNwQyxJQUFJc0QsY0FBY3hCLGNBQWNqQyxNQUFNLENBQUNHLFdBQVcsRUFBRXRDLE1BQU0sQ0FBQ3NDLFdBQVcsRUFBRWdDLFdBQVczRCxlQUFlNEQ7UUFDbEcsSUFBSXNCLFNBQVNoRSxPQUFPLENBQUNTLFdBQVcsQ0FBQ0wsQ0FBQztRQUNsQzs7Ozs7U0FLQyxHQUNESixRQUFRRyxPQUFPLENBQUMsU0FBVW9CLEVBQUUsRUFBRTBDLFlBQVk7WUFDdEMsSUFBSUMsV0FBVzNDLEdBQUduQixDQUFDO1lBQ25CLElBQUkrRCxlQUFlNUIsY0FBY2pDLE1BQU0sQ0FBQzJELGFBQWEsRUFBRTlGLE1BQU0sQ0FBQzhGLGFBQWEsRUFBRXhCLFdBQVczRCxlQUFlNEQ7WUFDdkcsSUFBSWpDLGVBQWV3RCxnQkFDZCxXQUFXQyxZQUFZRixVQUFVRSxXQUFXQyxnQkFDeENILFNBQVNELGVBQWVHLFlBQ3JCRixTQUFTRCxlQUFlRyxXQUFXQyxZQUFZLEdBQUk7Z0JBQzNELElBQUksQ0FBQ04sU0FBU1gsUUFBUSxDQUFDZSxlQUFlO29CQUNsQ0osU0FBU08sSUFBSSxDQUFDM0Q7b0JBQ2RvRCxTQUFTTyxJQUFJLENBQUNIO29CQUNkSixXQUFXcEosY0FBY0EsY0FBYyxFQUFFLEVBQUVvSixVQUFVLE9BQU87d0JBQUNwRDt3QkFBWXdEO3FCQUFhLEVBQUU7b0JBQ3hGSCxjQUFjRztnQkFDbEI7WUFDSjtRQUNKO0lBQ0o7SUFDQUgsY0FBYzdGO0lBQ2QscURBQXFEO0lBQ3JELE9BQU8vQyxNQUFNUCxJQUFJLENBQUMsSUFBSTBKLElBQUlSLFNBQVMvQixJQUFJO0FBQzNDO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0QsSUFBSW5HLGtCQUFrQixTQUFVMkksUUFBUSxFQUFFbkcsTUFBTSxFQUFFRixLQUFLLEVBQUVmLElBQUksRUFBRXVGLFNBQVMsRUFBRUMsWUFBWTtJQUNsRixJQUFJeEYsU0FBUyxLQUFLLEdBQUc7UUFBRUEsT0FBTztJQUFLO0lBQ25DLElBQUl1RixjQUFjLEtBQUssR0FBRztRQUFFQSxZQUFZO0lBQU87SUFDL0MsSUFBSUMsaUJBQWlCLEtBQUssR0FBRztRQUFFQSxlQUFlLFNBQVVoSCxLQUFLO1lBQUksT0FBT0E7UUFBTztJQUFHO0lBQ2xGLElBQUlvRCxnQkFBZ0IsQ0FBQyxHQUFHckQsUUFBUXFCLGVBQWUsRUFBRUk7SUFDakQsNEVBQTRFO0lBQzVFLElBQUlxRSxLQUFLLENBQUMsR0FBR3hFLFFBQVF3SCxRQUFRLEVBQUUsQ0FBQyxJQUFJQyxhQUFhakQsRUFBRSxDQUFDLEVBQUUsRUFBRWtELGdCQUFnQmxELEVBQUUsQ0FBQyxFQUFFO0lBQzdFLElBQUlFLEtBQUssQ0FBQyxHQUFHMUUsUUFBUXdILFFBQVEsRUFBRTdCLGFBQWF2RSxNQUFNLENBQUNGLE1BQU0sQ0FBQ0YsT0FBTyxDQUFDZSxrQkFBa0I0RixhQUFhakQsRUFBRSxDQUFDLEVBQUUsRUFBRWtELGdCQUFnQmxELEVBQUUsQ0FBQyxFQUFFO0lBQzdILGdGQUFnRjtJQUMvRSxJQUFHMUUsUUFBUTZILFNBQVMsRUFBRTtRQUNuQixJQUFJTixVQUFVO1lBQ1YsSUFBSWhFLFNBQVNnRSxTQUFTTyxTQUFTO1lBQy9CLElBQUl2RSxPQUFPeEYsTUFBTSxHQUFHLEdBQ2hCO1lBQ0osSUFBSWdLLFdBQVcsQ0FBQztZQUNoQixJQUFJQyxZQUFZVCxTQUFTVSxVQUFVO1lBQ25DOzs7OzthQUtDLEdBQ0QsSUFBSW5CLFdBQVdELFlBQVkzRixPQUFPOEcsV0FBV3pFLFFBQVFuQyxRQUFRc0UsV0FBVzNELGVBQWU0RDtZQUN2RiwrQ0FBK0M7WUFDL0MsSUFBSXVDLGVBQWV2QyxhQUFhdkUsTUFBTSxDQUFDRixNQUFNLENBQUNGLE9BQU8sQ0FBQ2U7WUFDdEQ7Ozs7O2FBS0MsR0FDRCxJQUFJK0UsU0FBUy9JLE1BQU0sRUFBRTtnQkFDakI7Ozs7aUJBSUMsR0FDRCxJQUFJb0ssV0FBV3JCLFNBQVMxQixNQUFNLENBQUMsU0FBVUosQ0FBQyxFQUFFb0QsQ0FBQyxFQUFFcEssQ0FBQyxFQUFFcUssQ0FBQztvQkFDL0MsT0FBT3JELEVBQUVqSCxNQUFNLEdBQUdMLGNBQWNBLGNBQWMsRUFBRSxFQUFFc0gsR0FBRyxPQUFPO3dCQUFDZ0QsU0FBUyxDQUFDSyxDQUFDLENBQUNySyxFQUFFLENBQUMsQ0FBQ3FGLENBQUM7cUJBQUMsRUFBRSxTQUFTO3dCQUFDMkUsU0FBUyxDQUFDSyxDQUFDLENBQUNySyxFQUFFLENBQUMsQ0FBQ3FGLENBQUM7cUJBQUM7Z0JBQ2pILEdBQUcsRUFBRTtnQkFDTDs7O2lCQUdDLEdBQ0QsSUFBSS9CLEtBQUtaLEdBQUcsQ0FBQzRELEtBQUssQ0FBQ2hELE1BQU02RyxjQUFjSCxTQUFTLENBQUM5RyxNQUFNLENBQUNtQyxDQUFDLEVBQUU7b0JBQ3ZEOzs7O3FCQUlDLEdBQ0QsSUFBSWlGLGdCQUFnQixFQUFFO29CQUN0QnhCLFNBQVMxRCxPQUFPLENBQUMsU0FBVW1GLEtBQUs7d0JBQzVCRCxjQUFjakIsSUFBSSxDQUFDakcsTUFBTSxDQUFDbUgsTUFBTSxDQUFDdkgsT0FBTyxDQUFDZTtvQkFDN0M7b0JBQ0E7OztxQkFHQyxHQUNEbUcsZUFBZS9KLE1BQU1QLElBQUksQ0FBQyxJQUFJMEosSUFBSWdCLGNBQWN2RCxJQUFJLENBQUMsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO3dCQUFJLE9BQU9qRCxXQUFXZ0QsS0FBS2hELFdBQVdpRDtvQkFBSSxLQUN4R0MsR0FBRyxDQUFDUyxjQUNKNkMsSUFBSSxDQUFDOUM7b0JBQ1Y7Ozs7O3FCQUtDLEdBQ0QsSUFBSStDLFFBQVFuSCxLQUFLWixHQUFHLENBQUM0RCxLQUFLLENBQUNoRCxNQUFNNkc7b0JBQ2pDLElBQUlPLE9BQU9wSCxLQUFLWCxHQUFHLENBQUMyRCxLQUFLLENBQUNoRCxNQUFNNkc7b0JBQ2hDLElBQUlRLFlBQVlwRixNQUFNLENBQUN1RCxRQUFRLENBQUNxQixTQUFTUyxPQUFPLENBQUNGLE1BQU0sQ0FBQyxDQUFDekMscUJBQXFCLEdBQUdMLEtBQUs7b0JBQ3RGbUMsU0FBU2pGLElBQUksR0FBRyxHQUFHdkUsTUFBTSxDQUFDK0MsS0FBS08sR0FBRyxDQUFDNEcsUUFBU0MsQ0FBQUEsT0FBT0MsU0FBUSxLQUFNLEdBQUc7b0JBQ3BFWixTQUFTakUsU0FBUyxHQUFHO2dCQUN6QixPQUNLO29CQUNELDBEQUEwRDtvQkFDMURpRSxTQUFTdkIsVUFBVSxHQUFHO2dCQUMxQjtZQUNKO1lBQ0EsbUNBQW1DO1lBQ25Db0IsY0FBY007WUFDZFIsY0FBY0s7UUFDbEI7SUFDSixHQUFHO1FBQUNSO1FBQVVuRztLQUFPO0lBQ3JCLE9BQU87UUFBQ3VHO1FBQVlGO0tBQVc7QUFDbkM7QUFDQS9JLHVCQUF1QixHQUFHRTtBQUMxQjs7Ozs7OztDQU9DLEdBQ0QsU0FBU2dGLGlCQUFpQjZCLE9BQU8sRUFBRWpDLE9BQU8sRUFBRUMsT0FBTyxFQUFFeEIsU0FBUztJQUMxRCxJQUFJdUMsS0FBS2lCLFFBQVFRLHFCQUFxQixJQUFJbkQsT0FBTzBCLEdBQUcxQixJQUFJLEVBQUVGLE1BQU00QixHQUFHNUIsR0FBRyxFQUFFZ0QsUUFBUXBCLEdBQUdvQixLQUFLLEVBQUVpRCxTQUFTckUsR0FBR3FFLE1BQU07SUFDNUcsT0FBT25KLFdBQVd1QyxhQUFhWCxLQUFLTyxHQUFHLENBQUM0QixVQUFXYixDQUFBQSxNQUFNaUcsU0FBUyxNQUFNdkgsS0FBS08sR0FBRyxDQUFDMkIsVUFBV1YsQ0FBQUEsT0FBTzhDLFFBQVE7QUFDL0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlL2xpYi91dGlscy5qcz83YzIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VUaHVtYk92ZXJsYXAgPSBleHBvcnRzLmFzc2VydFVucmVhY2hhYmxlID0gZXhwb3J0cy52b2lkRm4gPSBleHBvcnRzLmdldFRyYWNrQmFja2dyb3VuZCA9IGV4cG9ydHMucmVwbGFjZUF0ID0gZXhwb3J0cy5zY2hkID0gZXhwb3J0cy50cmFuc2xhdGUgPSBleHBvcnRzLmdldENsb3Nlc3RUaHVtYkluZGV4ID0gZXhwb3J0cy50cmFuc2xhdGVUaHVtYnMgPSBleHBvcnRzLmdldFBhZGRpbmdBbmRCb3JkZXIgPSBleHBvcnRzLmdldE1hcmdpbiA9IGV4cG9ydHMuY2hlY2tJbml0aWFsT3ZlcmxhcCA9IGV4cG9ydHMuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyA9IGV4cG9ydHMuY2hlY2tCb3VuZGFyaWVzID0gZXhwb3J0cy5pc1ZlcnRpY2FsID0gZXhwb3J0cy5yZWxhdGl2ZVZhbHVlID0gZXhwb3J0cy5ub3JtYWxpemVWYWx1ZSA9IGV4cG9ydHMuaXNTdGVwRGl2aXNpYmxlID0gZXhwb3J0cy5pc1RvdWNoRXZlbnQgPSBleHBvcnRzLmdldFN0ZXBEZWNpbWFscyA9IHZvaWQgMDtcbnZhciByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBnZXRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgIHZhciBkZWNpbWFscyA9IHN0ZXAudG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdO1xuICAgIHJldHVybiBkZWNpbWFscyA/IGRlY2ltYWxzLmxlbmd0aCA6IDA7XG59O1xuZXhwb3J0cy5nZXRTdGVwRGVjaW1hbHMgPSBnZXRTdGVwRGVjaW1hbHM7XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gKChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB8fFxuICAgICAgICAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSk7XG59XG5leHBvcnRzLmlzVG91Y2hFdmVudCA9IGlzVG91Y2hFdmVudDtcbmZ1bmN0aW9uIGlzU3RlcERpdmlzaWJsZShtaW4sIG1heCwgc3RlcCkge1xuICAgIHZhciByZXMgPSAobWF4IC0gbWluKSAvIHN0ZXA7XG4gICAgdmFyIHByZWNpc2lvbiA9IDg7XG4gICAgdmFyIHJvdW5kZWRSZXMgPSBOdW1iZXIocmVzLnRvRml4ZWQocHJlY2lzaW9uKSk7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJvdW5kZWRSZXMudG9TdHJpbmcoKSwgMTApID09PSByb3VuZGVkUmVzO1xufVxuZXhwb3J0cy5pc1N0ZXBEaXZpc2libGUgPSBpc1N0ZXBEaXZpc2libGU7XG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSwgaW5kZXgsIG1pbiwgbWF4LCBzdGVwLCBhbGxvd092ZXJsYXAsIHZhbHVlcykge1xuICAgIHZhciBCSUdfTlVNID0gMTBlMTA7XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogQklHX05VTSkgLyBCSUdfTlVNO1xuICAgIGlmICghYWxsb3dPdmVybGFwKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdmFsdWVzW2luZGV4IC0gMV07XG4gICAgICAgIHZhciBuZXh0ID0gdmFsdWVzW2luZGV4ICsgMV07XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYgPiB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0IDwgdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIGlmICh2YWx1ZSA8IG1pbilcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAvLyBgcmVtYWluZGVyYCBpcyBhIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZ2l2ZW4gdmFsdWUgYW5kIGEgZnVsbCBzdGVwIHZhbHVlXG4gICAgLy8gdGhhdCBpcyBjbG9zZXN0IGxvd2VyIHRvIHRoZSBnaXZlbiB2YWx1ZSBhbmQgaXMgaW4gdGhlIHJhbmdlIGJldHdlZW4gdGhlIG1pbiB2YWx1ZVxuICAgIC8vIGFuZCB0aGUgZ2l2ZW4gdmFsdWVcbiAgICB2YXIgcmVtYWluZGVyID0gTWF0aC5mbG9vcih2YWx1ZSAqIEJJR19OVU0gLSBtaW4gKiBCSUdfTlVNKSAlXG4gICAgICAgIE1hdGguZmxvb3Ioc3RlcCAqIEJJR19OVU0pO1xuICAgIHZhciBjbG9zZXN0TG93ZXJOdW0gPSBNYXRoLmZsb29yKHZhbHVlICogQklHX05VTSAtIE1hdGguYWJzKHJlbWFpbmRlcikpO1xuICAgIHZhciByb3VuZGVkID0gcmVtYWluZGVyID09PSAwID8gdmFsdWUgOiBjbG9zZXN0TG93ZXJOdW0gLyBCSUdfTlVNO1xuICAgIC8vIFZhbHVlcyB3aXRoIGEgcmVtYWluZGVyIGA8IHN0ZXAvMmAgYXJlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgbG93ZXIgdmFsdWVcbiAgICAvLyB3aGlsZSB2YWx1ZXMgd2l0aCBhIHJlbWFpbmRlciBgPSA+IHN0ZXAvMmAgYXJlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgYmlnZ2VyIHZhbHVlXG4gICAgdmFyIHJlcyA9IE1hdGguYWJzKHJlbWFpbmRlciAvIEJJR19OVU0pIDwgc3RlcCAvIDJcbiAgICAgICAgPyByb3VuZGVkXG4gICAgICAgIDogcm91bmRlZCArIHN0ZXA7XG4gICAgdmFyIGRlY2ltYWxQbGFjZXMgPSAoMCwgZXhwb3J0cy5nZXRTdGVwRGVjaW1hbHMpKHN0ZXApO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHJlcy50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplVmFsdWUgPSBub3JtYWxpemVWYWx1ZTtcbmZ1bmN0aW9uIHJlbGF0aXZlVmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbn1cbmV4cG9ydHMucmVsYXRpdmVWYWx1ZSA9IHJlbGF0aXZlVmFsdWU7XG5mdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlVwIHx8IGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uRG93bjtcbn1cbmV4cG9ydHMuaXNWZXJ0aWNhbCA9IGlzVmVydGljYWw7XG5mdW5jdGlvbiBjaGVja0JvdW5kYXJpZXModmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgaWYgKG1pbiA+PSBtYXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJtaW4gKFwiLmNvbmNhdChtaW4sIFwiKSBpcyBlcXVhbC9iaWdnZXIgdGhhbiBtYXggKFwiKS5jb25jYXQobWF4LCBcIilcIikpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ2YWx1ZSAoXCIuY29uY2F0KHZhbHVlLCBcIikgaXMgc21hbGxlciB0aGFuIG1pbiAoXCIpLmNvbmNhdChtaW4sIFwiKVwiKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInZhbHVlIChcIi5jb25jYXQodmFsdWUsIFwiKSBpcyBiaWdnZXIgdGhhbiBtYXggKFwiKS5jb25jYXQobWF4LCBcIilcIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tCb3VuZGFyaWVzID0gY2hlY2tCb3VuZGFyaWVzO1xuZnVuY3Rpb24gY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgLy8gc2V0IHNlbGVjdGVkVmFsdWUgdG8gbWluXG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAvLyBzZXQgc2VsZWN0ZWRWYWx1ZSB0byBtYXhcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXMgPSBjaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzO1xuZnVuY3Rpb24gY2hlY2tJbml0aWFsT3ZlcmxhcCh2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXZhbHVlcy5zbGljZSgxKS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaSkgeyByZXR1cm4gdmFsdWVzW2ldIDw9IGl0ZW07IH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidmFsdWVzPXtbXCIuY29uY2F0KHZhbHVlcywgXCJdfSBuZWVkcyB0byBiZSBzb3J0ZWQgd2hlbiBhbGxvd092ZXJsYXA9e2ZhbHNlfVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0luaXRpYWxPdmVybGFwID0gY2hlY2tJbml0aWFsT3ZlcmxhcDtcbmZ1bmN0aW9uIGdldE1hcmdpbihlbGVtZW50KSB7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBwYXJzZUludChzdHlsZVsnbWFyZ2luLXRvcCddLCAxMCksXG4gICAgICAgIGJvdHRvbTogcGFyc2VJbnQoc3R5bGVbJ21hcmdpbi1ib3R0b20nXSwgMTApLFxuICAgICAgICBsZWZ0OiBwYXJzZUludChzdHlsZVsnbWFyZ2luLWxlZnQnXSwgMTApLFxuICAgICAgICByaWdodDogcGFyc2VJbnQoc3R5bGVbJ21hcmdpbi1yaWdodCddLCAxMClcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRNYXJnaW4gPSBnZXRNYXJnaW47XG5mdW5jdGlvbiBnZXRQYWRkaW5nQW5kQm9yZGVyKGVsZW1lbnQpIHtcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHBhcnNlSW50KHN0eWxlWydwYWRkaW5nLXRvcCddLCAxMCkgKyBwYXJzZUludChzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddLCAxMCksXG4gICAgICAgIGJvdHRvbTogcGFyc2VJbnQoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10sIDEwKSArIHBhcnNlSW50KHN0eWxlWydib3JkZXItYm90dG9tLXdpZHRoJ10sIDEwKSxcbiAgICAgICAgbGVmdDogcGFyc2VJbnQoc3R5bGVbJ3BhZGRpbmctbGVmdCddLCAxMCkgKyBwYXJzZUludChzdHlsZVsnYm9yZGVyLWxlZnQtd2lkdGgnXSwgMTApLFxuICAgICAgICByaWdodDogcGFyc2VJbnQoc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSwgMTApICsgcGFyc2VJbnQoc3R5bGVbJ2JvcmRlci1yaWdodC13aWR0aCddLCAxMCksXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UGFkZGluZ0FuZEJvcmRlciA9IGdldFBhZGRpbmdBbmRCb3JkZXI7XG5mdW5jdGlvbiB0cmFuc2xhdGVUaHVtYnMoZWxlbWVudHMsIG9mZnNldHMsIHJ0bCkge1xuICAgIHZhciBpbnZlcnRlciA9IHJ0bCA/IC0xIDogMTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlKGVsZW1lbnQsIGludmVydGVyICogb2Zmc2V0c1tpbmRleF0ueCwgb2Zmc2V0c1tpbmRleF0ueSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnRyYW5zbGF0ZVRodW1icyA9IHRyYW5zbGF0ZVRodW1icztcbi8qKlxuICogVXRpbCBmdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgdGhlIGluZGV4IG9mIHRoZSB0aHVtYiB0aGF0IGlzIGNsb3NlcyB0byBhIGdpdmVuIHBvc2l0aW9uXG4gKiBAcGFyYW0gdGh1bWJzIC0gYXJyYXkgb2YgVGh1bWIgZWxlbWVudCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb21cbiAqIEBwYXJhbSBjbGllbnRYIC0gdGFyZ2V0IHggcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGNsaWVudFkgLSB0YXJnZXQgeSBwb3NpdGlvbiAobW91c2UvdG91Y2gpXG4gKiBAcGFyYW0gZGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdFRodW1iSW5kZXgodGh1bWJzLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgdGh1bWJJbmRleCA9IDA7XG4gICAgdmFyIG1pblRodW1iRGlzdGFuY2UgPSBnZXRUaHVtYkRpc3RhbmNlKHRodW1ic1swXSwgY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRodW1icy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGh1bWJEaXN0YW5jZSA9IGdldFRodW1iRGlzdGFuY2UodGh1bWJzW2ldLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pO1xuICAgICAgICBpZiAodGh1bWJEaXN0YW5jZSA8IG1pblRodW1iRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG1pblRodW1iRGlzdGFuY2UgPSB0aHVtYkRpc3RhbmNlO1xuICAgICAgICAgICAgdGh1bWJJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRodW1iSW5kZXg7XG59XG5leHBvcnRzLmdldENsb3Nlc3RUaHVtYkluZGV4ID0gZ2V0Q2xvc2VzdFRodW1iSW5kZXg7XG5mdW5jdGlvbiB0cmFuc2xhdGUoZWxlbWVudCwgeCwgeSkge1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgsIFwicHgsIFwiKS5jb25jYXQoeSwgXCJweClcIik7XG59XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWxleHJlYXJkb24vcmFmLXNjaGRcbnZhciBzY2hkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxhc3RBcmdzID0gW107XG4gICAgdmFyIGZyYW1lSWQgPSBudWxsO1xuICAgIHZhciB3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICAgICAgICBmbi5hcHBseSh2b2lkIDAsIGxhc3RBcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gd3JhcHBlckZuO1xufTtcbmV4cG9ydHMuc2NoZCA9IHNjaGQ7XG5mdW5jdGlvbiByZXBsYWNlQXQodmFsdWVzLCBpbmRleCwgdmFsdWUpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWVzLnNsaWNlKDApO1xuICAgIHJldFtpbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5yZXBsYWNlQXQgPSByZXBsYWNlQXQ7XG5mdW5jdGlvbiBnZXRUcmFja0JhY2tncm91bmQoX2EpIHtcbiAgICB2YXIgdmFsdWVzID0gX2EudmFsdWVzLCBjb2xvcnMgPSBfYS5jb2xvcnMsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBfYiA9IF9hLmRpcmVjdGlvbiwgZGlyZWN0aW9uID0gX2IgPT09IHZvaWQgMCA/IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0IDogX2IsIF9jID0gX2EucnRsLCBydGwgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYztcbiAgICBpZiAocnRsICYmIGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdDtcbiAgICB9XG4gICAgZWxzZSBpZiAocnRsICYmIHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ7XG4gICAgfVxuICAgIC8vIHNvcnQgdmFsdWVzIGFzY2VuZGluZ1xuICAgIHZhciBwcm9ncmVzcyA9IHZhbHVlcy5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSkubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKCh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKSkgKiAxMDA7IH0pO1xuICAgIHZhciBtaWRkbGUgPSBwcm9ncmVzcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcG9pbnQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChhY2MsIFwiLCBcIikuY29uY2F0KGNvbG9yc1tpbmRleF0sIFwiIFwiKS5jb25jYXQocG9pbnQsIFwiJSwgXCIpLmNvbmNhdChjb2xvcnNbaW5kZXggKyAxXSwgXCIgXCIpLmNvbmNhdChwb2ludCwgXCIlXCIpO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gXCJsaW5lYXItZ3JhZGllbnQoXCIuY29uY2F0KGRpcmVjdGlvbiwgXCIsIFwiKS5jb25jYXQoY29sb3JzWzBdLCBcIiAwJVwiKS5jb25jYXQobWlkZGxlLCBcIiwgXCIpLmNvbmNhdChjb2xvcnNbY29sb3JzLmxlbmd0aCAtIDFdLCBcIiAxMDAlKVwiKTtcbn1cbmV4cG9ydHMuZ2V0VHJhY2tCYWNrZ3JvdW5kID0gZ2V0VHJhY2tCYWNrZ3JvdW5kO1xuZnVuY3Rpb24gdm9pZEZuKCkgeyB9XG5leHBvcnRzLnZvaWRGbiA9IHZvaWRGbjtcbmZ1bmN0aW9uIGFzc2VydFVucmVhY2hhYmxlKHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWRuJ3QgZXhwZWN0IHRvIGdldCBoZXJlXCIpO1xufVxuZXhwb3J0cy5hc3NlcnRVbnJlYWNoYWJsZSA9IGFzc2VydFVucmVhY2hhYmxlO1xuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBncmFiYmluZyB0aGUgdHJ1ZSBsYXJnZXN0IHdpZHRoIG9mIGEgdGh1bWJcbiAqIGluY2x1ZGluZyB0aGUgbGFiZWxcbiAqIEBwYXJhbSB0aHVtYkVsIC0gVGh1bWIgZWxlbWVudCB0byBncmFiIHRoZSBsYXJnZXN0IHdpZHRoIGZyb21cbiAqIEBwYXJhbSB2YWx1ZSAtIFRodW1iIHZhbHVlLCBub3QgbGFiZWwgdmFsdWVcbiAqIEBwYXJhbSBzZXBhcmF0b3IgLSBMYWJlbCBzZXBhcmF0b3IgdmFsdWVcbiAqL1xudmFyIGdldFRodW1iV2lkdGggPSBmdW5jdGlvbiAodGh1bWJFbCwgdmFsdWUsIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKSB7XG4gICAgaWYgKHZhbHVlVG9MYWJlbCA9PT0gdm9pZCAwKSB7IHZhbHVlVG9MYWJlbCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07IH1cbiAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoX19zcHJlYWRBcnJheShbdGh1bWJFbF0sIEFycmF5LmZyb20odGh1bWJFbC5jaGlsZHJlbiksIHRydWUpLnJlZHVjZShmdW5jdGlvbiAod2lkdGgsIGVsKSB7XG4gICAgICAgIHZhciBlbFdpZHRoID0gTWF0aC5jZWlsKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgbGFiZWwgY29udGFpbnMgYSBtZXJnZWQgbGFiZWwgdmFsdWUsIGl0IHdvbid0IHJldHVybiB0aGUgdHJ1ZVxuICAgICAgICAgKiBsYWJlbCB3aWR0aCBmb3IgdGhhdCBUaHVtYi4gQ2xvbmUgdGhlIGxhYmVsIGFuZCBjaGFuZ2UgdGhlIHZhbHVlXG4gICAgICAgICAqIHRvIHRoYXQgaW5kaXZpZHVhbCBUaHVtYiB2YWx1ZSBpbiBvcmRlciB0byBncmFiIHRoZSB0cnVlIHdpZHRoLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGVsLmlubmVyVGV4dCAmJlxuICAgICAgICAgICAgZWwuaW5uZXJUZXh0LmluY2x1ZGVzKHNlcGFyYXRvcikgJiZcbiAgICAgICAgICAgIGVsLmNoaWxkRWxlbWVudENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZWxDbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIGVsQ2xvbmUuaW5uZXJIVE1MID0gdmFsdWVUb0xhYmVsKHZhbHVlLnRvRml4ZWQoZGVjaW1hbFBsYWNlcykpO1xuICAgICAgICAgICAgZWxDbG9uZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsQ2xvbmUpO1xuICAgICAgICAgICAgZWxXaWR0aCA9IE1hdGguY2VpbChlbENsb25lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxDbG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsV2lkdGggPiB3aWR0aCA/IGVsV2lkdGggOiB3aWR0aDtcbiAgICB9LCB0aHVtYkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSk7XG4gICAgcmV0dXJuIHdpZHRoO1xufTtcbi8qKlxuICogQnVsayBvZiBsb2dpYyBmb3IgdGh1bWIgb3ZlcmxhcHNcbiAqIENvbnNpZGVyIGEgc2NlbmFyaW8gd2l0aCA1IHRodW1icztcbiAqIFRodW1iIDEgb3ZlcmxhcHMgd2l0aCB0aHVtYiAwIGFuZCB0aHVtYiAyXG4gKiBUaHVtYiAyIG92ZXJsYXBzIHdpdGggdGh1bWIgM1xuICogV2UgbmVlZCBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIFswLCAxLCAyLCAzXVxuICogVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiB0aGUgZGlyZWN0bHkgb3ZlcmxhcHBpbmcgdGh1bWJzXG4gKiBhbmQgYWxsIHRodW1icyBvdmVybGFwcGluZyBsaW5rZWQgdG8gdGhvc2UgYW5kIHNvIG9uXG4gKiBAcGFyYW0gaW5kZXggLSBUaHVtYiBpbmRleCBjYWxjdWxhdGluZyBvdmVybGFwcyBmb3JcbiAqIEBwYXJhbSBvZmZzZXRzIC0gQ3VycmVudCBBcnJheSBvZiBUaHVtYiBvZmZzZXRzIGZvciBSYW5nZVxuICogQHBhcmFtIHRodW1icyAtIEFycmF5IG9mIFRodW1iIGVsZW1lbnRzXG4gKiBAcGFyYW0gdmFsdWVzIC0gQXJyYXkgb2YgVGh1bWIgdmFsdWVzXG4gKiBAcGFyYW0gc2VwYXJhdG9yIC0gU3RyaW5nIHNlcGFyYXRvciBmb3IgbWVyZ2VkIGxhYmVsIHZhbHVlc1xuICogQHJldHVybnMgb3ZlcmxhcHMgLSBBcnJheSBvZiBhbGwgb3ZlcmxhcHBpbmcgdGh1bWJzIGZyb20gdGhlIGluZGV4XG4gKi9cbnZhciBnZXRPdmVybGFwcyA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0cywgdGh1bWJzLCB2YWx1ZXMsIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKSB7XG4gICAgaWYgKHZhbHVlVG9MYWJlbCA9PT0gdm9pZCAwKSB7IHZhbHVlVG9MYWJlbCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07IH1cbiAgICB2YXIgb3ZlcmxhcHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgZnVuY3Rpb24gZm9yIGJ1aWxkaW5nIHRoZSBvdmVybGFwcyBBcnJheVxuICAgICAqIElmIGFuIG92ZXJsYXAgaXMgZm91bmQsIGZpbmQgdGhlIG92ZXJsYXBzIGZvciB0aGF0IG92ZXJsYXBcbiAgICAgKiBAcGFyYW0gdGh1bWJJbmRleCBjdXJyZW50IFRodW1iIGluZGV4IHRvIGZpbmQgb3ZlcmxhcHMgZnJvbVxuICAgICAqL1xuICAgIHZhciBidWlsZE92ZXJsYXBzID0gZnVuY3Rpb24gKHRodW1iSW5kZXgpIHtcbiAgICAgICAgdmFyIHRodW1iWFdpZHRoID0gZ2V0VGh1bWJXaWR0aCh0aHVtYnNbdGh1bWJJbmRleF0sIHZhbHVlc1t0aHVtYkluZGV4XSwgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpO1xuICAgICAgICB2YXIgdGh1bWJYID0gb2Zmc2V0c1t0aHVtYkluZGV4XS54O1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBUaHVtYiBvZmZzZXRzLCBpZiB0aGVyZSBpcyBhIG1hdGNoXG4gICAgICAgICAqIGFkZCB0aGUgdGh1bWJJbmRleCBhbmQgc2libGluZ0luZGV4IHRvIHRoZSBvdmVybGFwcyBBcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGVuIGJ1aWxkIG92ZXJsYXBzIGZyb20gdGhlIG92ZXJsYXBwaW5nIHNpYmxpbmdJbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgc2libGluZ0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2libGluZ1ggPSBfYS54O1xuICAgICAgICAgICAgdmFyIHNpYmxpbmdXaWR0aCA9IGdldFRodW1iV2lkdGgodGh1bWJzW3NpYmxpbmdJbmRleF0sIHZhbHVlc1tzaWJsaW5nSW5kZXhdLCBzZXBhcmF0b3IsIGRlY2ltYWxQbGFjZXMsIHZhbHVlVG9MYWJlbCk7XG4gICAgICAgICAgICBpZiAodGh1bWJJbmRleCAhPT0gc2libGluZ0luZGV4ICYmXG4gICAgICAgICAgICAgICAgKCh0aHVtYlggPj0gc2libGluZ1ggJiYgdGh1bWJYIDw9IHNpYmxpbmdYICsgc2libGluZ1dpZHRoKSB8fFxuICAgICAgICAgICAgICAgICAgICAodGh1bWJYICsgdGh1bWJYV2lkdGggPj0gc2libGluZ1ggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iWCArIHRodW1iWFdpZHRoIDw9IHNpYmxpbmdYICsgc2libGluZ1dpZHRoKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW92ZXJsYXBzLmluY2x1ZGVzKHNpYmxpbmdJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMucHVzaCh0aHVtYkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMucHVzaChzaWJsaW5nSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3ZlcmxhcHMsIHRydWUpLCBbdGh1bWJJbmRleCwgc2libGluZ0luZGV4XSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBidWlsZE92ZXJsYXBzKHNpYmxpbmdJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGJ1aWxkT3ZlcmxhcHMoaW5kZXgpO1xuICAgIC8vIFNvcnQgYW5kIHJlbW92ZSBkdXBsaWNhdGVzIGZyb20gdGhlIGJ1aWx0IG92ZXJsYXBzXG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChvdmVybGFwcy5zb3J0KCkpKTtcbn07XG4vKipcbiAqIEEgY3VzdG9tIFJlYWN0IEhvb2sgZm9yIGNhbGN1bGF0aW5nIHdoZXRoZXIgYSB0aHVtYiBvdmVybGFwc1xuICogYW5vdGhlciBhbmQgd2hldGhlciBsYWJlbHMgY291bGQvc2hvdWxkIG1lcmdlLlxuICogQHBhcmFtIHJhbmdlUmVmIC0gUmVhY3QgcmVmIHZhbHVlIG9mIFJhbmdlIGNvbXBvbmVudFxuICogQHBhcmFtIHZhbHVlcyAtIGN1cnJlbnQgUmFuZ2UgdmFsdWVzIEFycmF5XG4gKiBAcGFyYW0gaW5kZXggLSB0aHVtYiBpbmRleFxuICogQHBhcmFtIHN0ZXAgLSBzdGVwIHZhbHVlLCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBAcGFyYW0gc2VwYXJhdG9yIC0gc3RyaW5nIHRvIHNlcGFyYXRlIHRodW1iIHZhbHVlc1xuICogQHJldHVybnMgbGFiZWwgdmFsdWUgKyBzdHlsaW5nIGZvciB0aHVtYiBsYWJlbFxuICovXG52YXIgdXNlVGh1bWJPdmVybGFwID0gZnVuY3Rpb24gKHJhbmdlUmVmLCB2YWx1ZXMsIGluZGV4LCBzdGVwLCBzZXBhcmF0b3IsIHZhbHVlVG9MYWJlbCkge1xuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDAuMTsgfVxuICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBzZXBhcmF0b3IgPSAnIC0gJzsgfVxuICAgIGlmICh2YWx1ZVRvTGFiZWwgPT09IHZvaWQgMCkgeyB2YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9OyB9XG4gICAgdmFyIGRlY2ltYWxQbGFjZXMgPSAoMCwgZXhwb3J0cy5nZXRTdGVwRGVjaW1hbHMpKHN0ZXApO1xuICAgIC8vIENyZWF0ZSBpbml0aWFsIGxhYmVsIHN0eWxlIGFuZCB2YWx1ZS4gTGFiZWwgdmFsdWUgZGVmYXVsdHMgdG8gdGh1bWIgdmFsdWVcbiAgICB2YXIgX2EgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoe30pLCBsYWJlbFN0eWxlID0gX2FbMF0sIHNldExhYmVsU3R5bGUgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkodmFsdWVUb0xhYmVsKHZhbHVlc1tpbmRleF0udG9GaXhlZChkZWNpbWFsUGxhY2VzKSkpLCBsYWJlbFZhbHVlID0gX2JbMF0sIHNldExhYmVsVmFsdWUgPSBfYlsxXTtcbiAgICAvLyBXaGVuIHRoZSByYW5nZVJlZiBvciB2YWx1ZXMgY2hhbmdlLCB1cGRhdGUgdGhlIFRodW1iIGxhYmVsIHZhbHVlcyBhbmQgc3R5bGluZ1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmFuZ2VSZWYpIHtcbiAgICAgICAgICAgIHZhciB0aHVtYnMgPSByYW5nZVJlZi5nZXRUaHVtYnMoKTtcbiAgICAgICAgICAgIGlmICh0aHVtYnMubGVuZ3RoIDwgMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbmV3U3R5bGUgPSB7fTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRzXzEgPSByYW5nZVJlZi5nZXRPZmZzZXRzKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbnkgb3ZlcmxhcHMgZm9yIHRoZSBnaXZlbiBUaHVtYiBpbmRleC4gVGhpcyBtdXN0IHJldHVybiBhbGwgbGlua2VkXG4gICAgICAgICAgICAgKiBUaHVtYnMuIFNvIGlmIHRoZXJlIGFyZSA0IFRodW1icyBhbmQgVGh1bWJzIDIsIDMgYW5kIDQgb3ZlcmxhcC4gSWYgd2UgYXJlXG4gICAgICAgICAgICAgKiBnZXR0aW5nIHRoZSBvdmVybGFwcyBmb3IgVGh1bWIgMSBhbmQgaXQgb3ZlcmxhcHMgb25seSBUaHVtYiAyLCB3ZSBtdXN0IGdldFxuICAgICAgICAgICAgICogMiwgMyBhbmQgNCBhbHNvLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSBnZXRPdmVybGFwcyhpbmRleCwgb2Zmc2V0c18xLCB0aHVtYnMsIHZhbHVlcywgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpO1xuICAgICAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBsYWJlbCB2YWx1ZSBvZiB0aGUgVGh1bWIgdmFsdWVcbiAgICAgICAgICAgIHZhciBsYWJlbFZhbHVlXzEgPSB2YWx1ZVRvTGFiZWwodmFsdWVzW2luZGV4XS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUgYXJlIG92ZXJsYXBzIGZvciB0aGUgVGh1bWIsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0XG4gICAgICAgICAgICAgKiBMYWJlbCB2YWx1ZSBhbG9uZyB3aXRoIHRoZSByZWxldmFudCBzdHlsaW5nLiBXZSBvbmx5IHdhbnQgdG8gc2hvdyBhIExhYmVsXG4gICAgICAgICAgICAgKiBmb3IgdGhlIGxlZnQgbW9zdCBUaHVtYiBpbiBhbiBvdmVybGFwcGluZyBzZXQuXG4gICAgICAgICAgICAgKiBBbGwgb3RoZXIgVGh1bWJzIHdpbGwgYmUgc2V0IHRvIGRpc3BsYXk6IG5vbmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChvdmVybGFwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgYW4gQXJyYXkgb2YgdGhlIG9mZnNldHMgZm9yIHRoZSBvdmVybGFwcGluZyBUaHVtYnNcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIHNvIHdlIGNhbiBkZXRlcm1pbmUgaWYgdGhlIFRodW1iIHdlIGFyZSBsb29raW5nIGF0XG4gICAgICAgICAgICAgICAgICogaXMgdGhlIGxlZnQgbW9zdCB0aHVtYiBpbiBhbiBvdmVybGFwcGluZyBzZXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0c1ggPSBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGMsIGksIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID8gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBhLCB0cnVlKSwgW29mZnNldHNfMVtzW2ldXS54XSwgZmFsc2UpIDogW29mZnNldHNfMVtzW2ldXS54XTtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgb3VyIFRodW1iIGlzIHRoZSBsZWZ0IG1vc3QgVGh1bWIsIHdlIGNhbiBidWlsZCBhIExhYmVsIHZhbHVlXG4gICAgICAgICAgICAgICAgICogYW5kIHNldCB0aGUgc3R5bGUgZm9yIHRoYXQgTGFiZWxcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4uYXBwbHkoTWF0aCwgb2Zmc2V0c1gpID09PSBvZmZzZXRzXzFbaW5kZXhdLngpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEZpcnN0IGNhbGN1bGF0ZSB0aGUgTGFiZWwgdmFsdWUuIFRvIGRvIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAqIGdyYWIgYWxsIHRoZSB2YWx1ZXMgZm9yIHRoZSBUaHVtYnMgaW4gb3VyIG92ZXJsYXBzLlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGVuIGNvbnZlcnQgdGhhdCB0byBhIFNldCBhbmQgc29ydCBpdCB3aGlsc3QgcmVtb3ZpbmcgZHVwbGljYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFZhbHVlc18xID0gW107XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLmZvckVhY2goZnVuY3Rpb24gKHRodW1iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFZhbHVlc18xLnB1c2godmFsdWVzW3RodW1iXS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiAgVXBkYXRlIHRoZSBsYWJlbFZhbHVlIHdpdGggdGhlIHJlc3VsdGluZyBBcnJheVxuICAgICAgICAgICAgICAgICAgICAgKiAgam9pbmVkIGJ5IG91ciBkZWZpbmVkIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbGFiZWxWYWx1ZV8xID0gQXJyYXkuZnJvbShuZXcgU2V0KGxhYmVsVmFsdWVzXzEuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gcGFyc2VGbG9hdChhKSAtIHBhcnNlRmxvYXQoYik7IH0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAodmFsdWVUb0xhYmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIExhc3RseSwgYnVpbGQgdGhlIGxhYmVsIHN0eWxpbmcuIFRoZSBsYWJlbCBzdHlsaW5nIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICogcG9zaXRpb24gdGhlIGxhYmVsIGFuZCBhcHBseSBhIHRyYW5zZm9ybSBzbyB0aGF0IGl0J3MgY2VudGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIHdhbnQgdGhlIGNlbnRlciBwb2ludCBiZXR3ZWVuIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGxlZnQgbW9zdCBUaHVtYlxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHJpZ2h0IG1vc3QgVGh1bWIuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBvZmZzZXRzWCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2Zmc2V0c1gpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFdpZHRoID0gdGh1bWJzW292ZXJsYXBzW29mZnNldHNYLmluZGV4T2YobGFzdCldXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KE1hdGguYWJzKGZpcnN0IC0gKGxhc3QgKyBsYXN0V2lkdGgpKSAvIDIsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgMCknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIFRodW1iIGlzbid0IHRoZSBsZWZ0IG1vc3QgVGh1bWIsIGhpZGUgdGhlIExhYmVsIVxuICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYWJlbCB2YWx1ZSBhbmQgc3R5bGVcbiAgICAgICAgICAgIHNldExhYmVsVmFsdWUobGFiZWxWYWx1ZV8xKTtcbiAgICAgICAgICAgIHNldExhYmVsU3R5bGUobmV3U3R5bGUpO1xuICAgICAgICB9XG4gICAgfSwgW3JhbmdlUmVmLCB2YWx1ZXNdKTtcbiAgICByZXR1cm4gW2xhYmVsVmFsdWUsIGxhYmVsU3R5bGVdO1xufTtcbmV4cG9ydHMudXNlVGh1bWJPdmVybGFwID0gdXNlVGh1bWJPdmVybGFwO1xuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyB0aGUgZGlzdGFuY2Ugb2YgdGhlIGNlbnRlciBvZiBhIHRodW1iXG4gKiBmb3JtIGEgZ2l2ZW4gbW91c2UvdG91Y2ggdGFyZ2V0J3MgcG9zaXRpb25cbiAqIEBwYXJhbSB0aHVtYkVsIC0gVGh1bWIgZWxlbWVudCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb21cbiAqIEBwYXJhbSBjbGllbnRYIC0gdGFyZ2V0IHggcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGNsaWVudFkgLSB0YXJnZXQgeSBwb3NpdGlvbiAobW91c2UvdG91Y2gpXG4gKiBAcGFyYW0gZGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0VGh1bWJEaXN0YW5jZSh0aHVtYkVsLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgX2EgPSB0aHVtYkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgcmV0dXJuIGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IE1hdGguYWJzKGNsaWVudFkgLSAodG9wICsgaGVpZ2h0IC8gMikpIDogTWF0aC5hYnMoY2xpZW50WCAtIChsZWZ0ICsgd2lkdGggLyAyKSk7XG59XG4iXSwibmFtZXMiOlsiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpIiwibCIsImFyIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJjb25jYXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVzZVRodW1iT3ZlcmxhcCIsImFzc2VydFVucmVhY2hhYmxlIiwidm9pZEZuIiwiZ2V0VHJhY2tCYWNrZ3JvdW5kIiwicmVwbGFjZUF0Iiwic2NoZCIsInRyYW5zbGF0ZSIsImdldENsb3Nlc3RUaHVtYkluZGV4IiwidHJhbnNsYXRlVGh1bWJzIiwiZ2V0UGFkZGluZ0FuZEJvcmRlciIsImdldE1hcmdpbiIsImNoZWNrSW5pdGlhbE92ZXJsYXAiLCJjaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzIiwiY2hlY2tCb3VuZGFyaWVzIiwiaXNWZXJ0aWNhbCIsInJlbGF0aXZlVmFsdWUiLCJub3JtYWxpemVWYWx1ZSIsImlzU3RlcERpdmlzaWJsZSIsImlzVG91Y2hFdmVudCIsImdldFN0ZXBEZWNpbWFscyIsInJlYWN0XzEiLCJyZXF1aXJlIiwidHlwZXNfMSIsInN0ZXAiLCJkZWNpbWFscyIsInRvU3RyaW5nIiwic3BsaXQiLCJldmVudCIsInRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIm1pbiIsIm1heCIsInJlcyIsInByZWNpc2lvbiIsInJvdW5kZWRSZXMiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwicGFyc2VJbnQiLCJpbmRleCIsImFsbG93T3ZlcmxhcCIsInZhbHVlcyIsIkJJR19OVU0iLCJNYXRoIiwicm91bmQiLCJwcmV2IiwibmV4dCIsInJlbWFpbmRlciIsImZsb29yIiwiY2xvc2VzdExvd2VyTnVtIiwiYWJzIiwicm91bmRlZCIsImRlY2ltYWxQbGFjZXMiLCJwYXJzZUZsb2F0IiwiZGlyZWN0aW9uIiwiRGlyZWN0aW9uIiwiVXAiLCJEb3duIiwiUmFuZ2VFcnJvciIsImV2ZXJ5IiwiaXRlbSIsImVsZW1lbnQiLCJzdHlsZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJlbGVtZW50cyIsIm9mZnNldHMiLCJydGwiLCJpbnZlcnRlciIsImZvckVhY2giLCJ4IiwieSIsInRodW1icyIsImNsaWVudFgiLCJjbGllbnRZIiwidGh1bWJJbmRleCIsIm1pblRodW1iRGlzdGFuY2UiLCJnZXRUaHVtYkRpc3RhbmNlIiwidGh1bWJEaXN0YW5jZSIsInRyYW5zZm9ybSIsImZuIiwibGFzdEFyZ3MiLCJmcmFtZUlkIiwid3JhcHBlckZuIiwiYXJncyIsIl9pIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYXBwbHkiLCJyZXQiLCJfYSIsImNvbG9ycyIsIl9iIiwiUmlnaHQiLCJfYyIsIkxlZnQiLCJwcm9ncmVzcyIsInNvcnQiLCJhIiwiYiIsIm1hcCIsIm1pZGRsZSIsInJlZHVjZSIsImFjYyIsInBvaW50IiwiRXJyb3IiLCJnZXRUaHVtYldpZHRoIiwidGh1bWJFbCIsInNlcGFyYXRvciIsInZhbHVlVG9MYWJlbCIsIndpZHRoIiwiY2VpbCIsImNoaWxkcmVuIiwiZWwiLCJlbFdpZHRoIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaW5uZXJUZXh0IiwiaW5jbHVkZXMiLCJjaGlsZEVsZW1lbnRDb3VudCIsImVsQ2xvbmUiLCJjbG9uZU5vZGUiLCJpbm5lckhUTUwiLCJ2aXNpYmlsaXR5IiwiZG9jdW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImdldE92ZXJsYXBzIiwib3ZlcmxhcHMiLCJidWlsZE92ZXJsYXBzIiwidGh1bWJYV2lkdGgiLCJ0aHVtYlgiLCJzaWJsaW5nSW5kZXgiLCJzaWJsaW5nWCIsInNpYmxpbmdXaWR0aCIsInB1c2giLCJTZXQiLCJyYW5nZVJlZiIsInVzZVN0YXRlIiwibGFiZWxTdHlsZSIsInNldExhYmVsU3R5bGUiLCJsYWJlbFZhbHVlIiwic2V0TGFiZWxWYWx1ZSIsInVzZUVmZmVjdCIsImdldFRodW1icyIsIm5ld1N0eWxlIiwib2Zmc2V0c18xIiwiZ2V0T2Zmc2V0cyIsImxhYmVsVmFsdWVfMSIsIm9mZnNldHNYIiwiYyIsInMiLCJsYWJlbFZhbHVlc18xIiwidGh1bWIiLCJqb2luIiwiZmlyc3QiLCJsYXN0IiwibGFzdFdpZHRoIiwiaW5kZXhPZiIsImhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-range/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ReactRange.js":
/*!**********************************!*\
  !*** ./components/ReactRange.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-range */ \"(app-pages-browser)/./node_modules/react-range/lib/index.js\");\n/* __next_internal_client_entry_do_not_use__  auto */ \n\n\nclass SuperSimple extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    render() {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_range__WEBPACK_IMPORTED_MODULE_2__.Range, {\n            step: 0.1,\n            min: 0,\n            max: 100,\n            values: this.state.values,\n            onChange: (values)=>this.setState({\n                    values\n                }),\n            renderTrack: (param)=>{\n                let { props, children } = param;\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    ...props,\n                    style: {\n                        ...props.style,\n                        height: \"6px\",\n                        width: \"100%\",\n                        backgroundColor: \"#ccc\"\n                    },\n                    children: children\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\emrel\\\\OneDrive\\\\Masa\\xfcst\\xfc\\\\bubitecek\\\\components\\\\ReactRange.js\",\n                    lineNumber: 17,\n                    columnNumber: 21\n                }, void 0);\n            },\n            renderThumb: (param)=>{\n                let { props } = param;\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    ...props,\n                    style: {\n                        ...props.style,\n                        height: \"42px\",\n                        width: \"42px\",\n                        backgroundColor: \"#999\"\n                    }\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\emrel\\\\OneDrive\\\\Masa\\xfcst\\xfc\\\\bubitecek\\\\components\\\\ReactRange.js\",\n                    lineNumber: 30,\n                    columnNumber: 21\n                }, void 0);\n            }\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\emrel\\\\OneDrive\\\\Masa\\xfcst\\xfc\\\\bubitecek\\\\components\\\\ReactRange.js\",\n            lineNumber: 10,\n            columnNumber: 13\n        }, this);\n    }\n    constructor(...args){\n        super(...args);\n        this.state = {\n            values: [\n                50\n            ]\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvUmVhY3RSYW5nZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFFK0I7QUFDSztBQUVwQyxNQUFNRSxvQkFBb0JGLDRDQUFlO0lBRXJDSSxTQUFTO1FBQ0wscUJBQ0ksOERBQUNILDhDQUFLQTtZQUNGSSxNQUFNO1lBQ05DLEtBQUs7WUFDTEMsS0FBSztZQUNMQyxRQUFRLElBQUksQ0FBQ0MsS0FBSyxDQUFDRCxNQUFNO1lBQ3pCRSxVQUFVLENBQUNGLFNBQVcsSUFBSSxDQUFDRyxRQUFRLENBQUM7b0JBQUVIO2dCQUFPO1lBQzdDSSxhQUFhO29CQUFDLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFO3FDQUM3Qiw4REFBQ0M7b0JBQ0ksR0FBR0YsS0FBSztvQkFDVEcsT0FBTzt3QkFDSCxHQUFHSCxNQUFNRyxLQUFLO3dCQUNkQyxRQUFRO3dCQUNSQyxPQUFPO3dCQUNQQyxpQkFBaUI7b0JBQ3JCOzhCQUVDTDs7Ozs7OztZQUdUTSxhQUFhO29CQUFDLEVBQUVQLEtBQUssRUFBRTtxQ0FDbkIsOERBQUNFO29CQUNJLEdBQUdGLEtBQUs7b0JBQ1RHLE9BQU87d0JBQ0gsR0FBR0gsTUFBTUcsS0FBSzt3QkFDZEMsUUFBUTt3QkFDUkMsT0FBTzt3QkFDUEMsaUJBQWlCO29CQUNyQjs7Ozs7Ozs7Ozs7O0lBS3BCOzs7YUFuQ0FWLFFBQVE7WUFBRUQsUUFBUTtnQkFBQzthQUFHO1FBQUM7O0FBb0MzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1JlYWN0UmFuZ2UuanM/ZDI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICdyZWFjdC1yYW5nZSc7XHJcblxyXG5jbGFzcyBTdXBlclNpbXBsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBzdGF0ZSA9IHsgdmFsdWVzOiBbNTBdIH07XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPFJhbmdlXHJcbiAgICAgICAgICAgICAgICBzdGVwPXswLjF9XHJcbiAgICAgICAgICAgICAgICBtaW49ezB9XHJcbiAgICAgICAgICAgICAgICBtYXg9ezEwMH1cclxuICAgICAgICAgICAgICAgIHZhbHVlcz17dGhpcy5zdGF0ZS52YWx1ZXN9XHJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlcykgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlcyB9KX1cclxuICAgICAgICAgICAgICAgIHJlbmRlclRyYWNrPXsoeyBwcm9wcywgY2hpbGRyZW4gfSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJvcHMuc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICc2cHgnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNjY2MnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGh1bWI9eyh7IHByb3BzIH0pID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5wcm9wc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3BzLnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnNDJweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzQycHgnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzk5OSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59Il0sIm5hbWVzIjpbIlJlYWN0IiwiUmFuZ2UiLCJTdXBlclNpbXBsZSIsIkNvbXBvbmVudCIsInJlbmRlciIsInN0ZXAiLCJtaW4iLCJtYXgiLCJ2YWx1ZXMiLCJzdGF0ZSIsIm9uQ2hhbmdlIiwic2V0U3RhdGUiLCJyZW5kZXJUcmFjayIsInByb3BzIiwiY2hpbGRyZW4iLCJkaXYiLCJzdHlsZSIsImhlaWdodCIsIndpZHRoIiwiYmFja2dyb3VuZENvbG9yIiwicmVuZGVyVGh1bWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ReactRange.js\n"));

/***/ })

});